# 背景

一条 SQL 语句，正常执行时特别快，但是有时会变得特别慢，并且这样的场景很难复现，是随机出现，而且持续时间还很短

答：可能是刷脏页(flush)



# SQL语句为什么'变慢了'

## 类比

1. 掌柜的记忆 -> 内存
2. 粉板 -> 日志文件(redo log)

3. 掌柜记账的账本 -> 数据文件



## WAL机制InnoDB更新语句

> WAL全称是write ahead log，也就是更新数据之前先更新日志

1. 先更新内存（掌柜记忆）
2. 记录日志文件redo log（粉板），此时即返回客户端表示本次更新成功，写redo log也是一个磁盘操作（是顺序写）
3. 等待空闲时间写入磁盘（更新账本）（是随机写）



> 虽然redo log也是写磁盘，但是相比找具体某个记录，它是直接放到磁盘就可以了，是顺序写，而不是随机写，写入磁盘才是随机写



## 脏页/干净页/flush

* 脏页：当`内存数据页`跟`磁盘数据页`内容不一致时，这个内存页称为脏页

* 干净页：当`内存的数据`写入到磁盘后，内存数据页和磁盘数据页的内容就一致了，这个内存页称为“干净页”
* flush操作：即把内存的数据写入磁盘（也叫刷脏页）



## 示例

“孔乙己赊账”的整个操作过程。假设原来孔乙`己欠账 10 文`，这次又要`赊 9 文`。

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/12_%E5%AD%94%E4%B9%99%E5%B7%B1%E8%B5%8A%E8%B4%A6%E6%9B%B4%E6%96%B0%E5%92%8Cflush%E8%BF%87%E7%A8%8B.jpeg)



# 4种刷脏页(flush)的场景

思考：掌柜在什么情况下会把粉板上的赊账记录改到账本上？（即什么时候需要刷脏页）

1. 生意太好，掌柜记不住了

   > 内存不足

2. 粉板满了 

   > InnoDB的redo log写满了

3. 生意不忙时或者打烊后，掌柜闲着也是闲着 

   > 即MySQL 认为系统“空闲”时，更新账本

4. 年底了酒店关门几天，把账结清一下 

   > 即MySQL 正常关闭的情况



### 第1种场景：内存不足

当需要新的`内存数据页`，而内存不够用时，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。内存不足其实是常态，对数据库性能影响不大



**问题**

能不能直接把内存淘汰掉，下次需要请求时，从磁盘读入数据页，然后拿 redo log 出来应用不就行了？

答：这里其实是从性能考虑的

> 刷脏页一定会写盘，就保证了每个数据页有两种状态：
>
> * 一种是内存里存在，内存里就肯定是正确的结果，直接返回
> * 另一种是内存里没有数据，就可以肯定磁盘数据文件上是正确的结果，读入内存后返回。这样的效率最高



### 第2种场景：redo log满了

InnoDB 的 redo log 写满了，则需要把一些redo log记录到磁盘，这时系统会`停止所有更新操作`，把 checkpoint 往前推进，便于redo log 留出空间可以继续写。



比如下图中，把 checkpoint 位置从 CP 推进到 CP’，就需要`将两个点之间的日志（浅绿色部分），对应的所有脏页都 flush 到磁盘上`。之后，图中从 write pos 到 CP’之间就是可以再写入的 redo log 的区域。

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/12_redolog%E7%8A%B6%E6%80%81%E5%9B%BE.jpeg)



### 第3种场景：MySQL空闲

 即MySQL 认为系统“空闲”时刷脏页，因为这时系统没什么压力



### 第4种场景：MySQL关闭

MySQL 正常关闭时，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动时，就可以直接从磁盘上读数据，启动速度会很快。



### 性能影响对比

1. MySQL空闲跟关闭，没什么性能影响
2. 内存不够用了，要flush，这种情况其实是常态。
3. redo log 写满了，要flush，这种情况是 InnoDB 要尽量避免的。

> 因为出现redo log写满时，整个系统就不能再接受更新了，所有的更新都必须堵住。此时候更新数会跌为 0



#### Buffer pool缓冲池

InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的`内存页有三种状态`：

1. 第一种是，还没有使用的
2. 第二种是，使用了并且是干净页
3. 第三种是，使用了并且是脏页



InnoDB 的策略是`尽量使用内存`，因此对于一个长时间运行的库来说，未被使用的页面很少。



而当要读入的数据页没有在内存时，就必须`到缓冲池中申请一个数据页`。

> 这时只能把`最久不使用`的数据页从内存中淘汰掉：
>
>   如果要淘汰的是一个干净页，就直接释放出来复用；
>
>   但如果淘汰的是脏页，就必须将脏页先刷到磁盘，变成干净页后才能复用



**刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：**

1. 一个查询要淘汰的`脏页个数太多`，会导致查询的响应时间明显变长

2. 日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的


所以，InnoDB 需要有`控制脏页比例的机制`，来尽量避免上面的这两种情况。



# InnoDB刷脏页控制策略

首先，要正确地告诉 InnoDB 所在主机的` IO 能力`，这样 InnoDB 才能知道需要全力刷脏页时，可以刷多快。



## innodb_io_capacity 参数

这个参数告诉 InnoDB 所在主机的磁盘能力

> 建议设置成磁盘的 IOPS



磁盘的 IOPS 可以通过 fio 工具来测试，下面的语句是用来`测试磁盘随机读写的命令`

```bash
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
```



如果刷脏页参数设置不合理，会影响性能

> 如果机器很好，而设置innodb_io_capacity偏小，刷脏页会刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能



## InnoDB 怎么控制引擎按照“全力”的百分比来刷脏

**InnoDB 的刷盘速度要参考的两个因素**

1. 一个是脏页比例（内存脏页过多）
2. 一个是 redo log 写盘速度（redo 写满）

InnoDB 会根据这两个因素先单独算出两个数字。



**innodb_max_dirty_pages_pct 参数**

参数 `innodb_max_dirty_pages_pct `是脏页比例上限，默认值是 75%



InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样：

```c++
F1(M)
{
  if M>=innodb_max_dirty_pages_pct then
      return 100;
  return 100*M/innodb_max_dirty_pages_pct;
}
```

InnoDB 每次写入的日志都有一个`序`号，`当前写入的序号`跟` checkpoint 对应的序号`之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为` F2(N)`。

F2(N) 算法比较复杂，你只要知道` N 越大，算出来的值越大`就好了。



然后，根据上述算得的 F1(M) 和 F2(N) 两个值，`取其中较大的值记为 R`，之后引擎就可以按照` innodb_io_capacity 定义的能力 乘以 R% `来控制刷脏页的速度。



一个简单的流程图

图中的 F1、F2 就是上面我们通过脏页比例和 redo log 写入速度算出来的两个值。

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/12_InnoDB%E5%88%B7%E8%84%8F%E9%A1%B5%E9%80%9F%E5%BA%A6%E7%AD%96%E7%95%A5.jpeg)

InnoDB 会在后台刷脏页，而`刷脏页的过程是要将内存页写入磁盘`。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 `IO 资源`并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。



要尽量避免这种情况，就要合理地设置 `innodb_io_capacity 的值`，并且平时要多关注`脏页比例`，不要让它经常接近 `75%`。



**得到脏页比例**

其中，`脏页比例是通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到的`，

具体的命令参考下面的代码：

```sql
mysql> select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';
select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';
select @a/@b;
```



一旦一个`查询请求`需要在执行过程中`先 flush 掉一个脏页`时，这个查询就可能要比平时慢了



## 连坐刷脏

**MySQL 中的一个机制，可能让查询会更慢**

在准备刷一个脏页时，如果这个数据页`旁边的数据页刚好是脏页`，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以`继续蔓延`，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。



**innodb_flush_neighbors参数**

在 InnoDB 中，`innodb_flush_neighbors` 参数就是用来控制这个连坐刷脏行为的，值为 1 时会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。

> 在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了



**建议**

1. 找“邻居”这个优化在机械硬盘时代是很有意义的，可以`减少很多随机 IO`。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升

2. 而如果使用的是 SSD 这类 IOPS 比较高的设备的话，建议把 innodb_flush_neighbors 的值设置成 0。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。

   