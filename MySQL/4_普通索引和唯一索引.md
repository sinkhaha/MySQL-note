# 普通索引和唯一索引的区别

## 前提：表T的建表语句

```sql
create table T(
    id int primary key, 
    k int not null, 
    name varchar(16),
    index (k)
) engine=InnoDB;
```



## 从性能角度考虑两者的区别

## 1、对查询语句性能的影响

两者对查询语句的性能`几乎无区别`



**分析**

```sql
-- 执行如下语句
select id from T where k=5
```

此语句先从B+树的树根开始，按层搜索到`叶子节点`(数据页)，然后可以认为数据页内部通过`二分法`来`定位记录`

* 如果k建立了`普通索引`，查找到满足条件的`第一个记录k=5后`，需要查找`下一个记录`，直到碰到`第一个不满足 k=5 `条件的记录
* 如果k建立了`唯一索引`，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会`停止继续检索`



这两种带来的性能差距是微乎其微的，因为

1. InnoDB 的数据是按`数据页`为单位来`读写`的

   > 当需要读一条记录时，并不是将这个记录本身从磁盘读出来，而是`以页为单位`，将其整体读入`内存`。
   >
   > 在 InnoDB 中，每个数据页的大小默认是 `16KB`

2. 因为引擎是按页读写的，当找到 k=5 的记录时，`它所在的数据页就都在内存里了`。对于普通索引来说，要多做的那一次`“查找和判断下一条记录”`的操作，就只需要`一次指针寻找`和`一次计算`

3. 当然，如果 k=5 这个记录刚好是`这个数据页的最后一个记录`，那么要取下一个记录，必须`读取下一个数据页`，这个操作会稍微复杂一些

4. 对于`整型字段`，一个`数据页`可以放`近千个 key`，因此出现步骤3这种情况的概率会很低，对性能的影响可以忽略不计

   

## 2、对更新语句性能的影响

### **更新一个数据页的流程**

1. 当需要更新一个数据页时，数据页在内存中，直接更新
2. 数据页不在内存中，在`不影响数据一致性`的前提下，InnoDB 将更新操作`缓存到change buffer中`，不需要从磁盘读入这个数据页
3. 下次查询时要访问这个数据页，才将数据页`读入内存`，然后执行change buffer中与这个页有关的操作



### Change buffer

#### 什么是 change buffer

change buffer记录了数据页的`更新操作的缓存`，存在内存中，也会被`写入到磁盘上`，会持久化数据



#### change buffer的大小

change buffer 用的是 `buffer pool `里的内存，因此`不能无限增大`。



change buffer 的大小，通过参数` innodb_change_buffer_max_size `来动态设置。

设置为 50 时，表示 change buffer 的大小`最多只能占用 buffer pool 的 50%`



#### change buffer的作用

1. 将更新操作`先记录在 change buffer`，`减少读磁盘`，更新语句的`执行速度`会得到明显的提升

2. 避免占用内存，提高`内存利用率`

   > 假设更新需要先读取数据入内存，而数据读入内存是需要`占用 buffer pool `的



#### 什么是merge

将 change buffer 中的操作`应用到原数据页`，得到`最新结果`的过程称为` merge` 



#### merge的时机

1. `访问这个数据页，把数据页读入内存时`会触发
2. 系统有`后台线程会定期 merge`
3. 在数据库`正常关闭（shutdown）`的过程中，也会执行 merge 操作



#### 什么条件下使用change buffer 

`唯一索引的更新`不能使用，实际也只有`普通索引`可以使用

> 对于`唯一索引`，所有的更新操作都要`先判断`这个操作`是否违反唯一性约束`

> 比如，要插入 k=4，要`先判断`表中是否已经存在 k=4 的记录，此时必须要`将数据页读入内存才能判断`
>
> （如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了）



**如果要在这张表中插入一个新记录 k=4 的话，InnoDB 的处理流程如下，分两种情况：**

1. 第一种情况是，这个记录要更新的目标页在`内存`中：

* 对于`唯一索引`，找到 3 和 5 之间的位置，判断到`没有冲突`，插入这个值，语句执行结束
* 对于`普通索引`，找到 3 和 5 之间的位置，插入这个值，语句执行结束

普通索引和唯一索引`对更新语句性能影响的差别`，只是`一个判断`，只会耗费微小的 CPU 时间



2. 第二种情况是，这个记录要更新的目标页`不在内存中`：

* 对于`唯一索引`，需要将数据页`读入内存`，判断到没有冲突，插入这个值，语句执行结束

* 对于`普通索引`，则是将`更新记录在 change buffer`，语句执行就结束了

  

将数据`从磁盘读入内存`涉及`随机 IO `的访问，是数据库里面成本最高的操作之一。

change buffer 因为`减少了随机磁盘访问`，所以对更新性能的提升是会很明显的。



#### change buffer 的使用场景

 `change buffer 对更新过程有加速作用`，change buffer 只限于用在`普通索引`的场景下，而`不适用于唯一索引`



**普通索引的所有场景使用 change buffer 都可以起到加速作用吗？**

1. merge 时才是真正`进行数据更新的时刻`，而 change buffer 的主要目的就是`将记录的变更动作缓存下来`，所以在一个数据页做 merge 之前，`change buffer 记录的变更越多`（也就是这个页面上要更新的次数越多），收益就越大

2. 对于`写多读少`的业务，页面在写完以后马上`被访问到的概率比较小`，此时 change buffer 的使用`效果最好`

   > 如`账单类、日志类`类系统

3. 如果业务是`更新之后马上会做查询`，即使满足了条件，将更新先记录在 change buffer，但由于马上要访问这个数据页，会`立即触发 merge 过程`。这样`随机访问 IO 的次数不会减少`，反而`增加了 change buffer 的维护代价`。所以，对于这种业务模式来说，change buffer 反而起到了副作用。



## 索引选择和实践

1. 这两种索引在`查询能力`上是没差别的

2. 主要考虑的是`对更新性能`的影响，建议尽量选择`普通索引`

3. 如果所有的更新后面都马上伴随着对这个记录的查询，那么应该`关闭 change buffer`。而在其他情况下，change buffer 都能提升更新性能

   

## change buffer 和 redo log

现在在表上执行这个插入语句：

```sql
insert into t(id,k) values(id1,k1),(id2,k2);
```



假设当`前 k 索引树`的状态，查找到位置后

* k1 所在的数据页`在内存 (InnoDB buffer pool) `中

* k2 所在的数据页`不在内存`中

  

如下图所示是`带 change buffer 的更新状态图`

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/09_%E7%B4%A2%E5%BC%95_01.png)



这条更新语句涉及了4个部分：

* 内存
* redo log（ib_log_fileX）
* 数据表空间（t.ibd）
* 系统表空间（ibdata1）



**这条更新语句做了如下的操作（按照图中的数字顺序）：**

1. Page 1 在内存中，直接更新内存
2. Page 2 没有在内存中，就在内存的` change buffer 区域记录下“我要往 Page 2 插入一行”这个信息`
3. 将上述两个动作记入` redo log 中`（图中的 3和4）

做完上面这些，`事务就可以完成了`。



所以，执行这条更新语句的成本很低，就是`写了两处内存`，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是`顺序写`的。

图中的两个虚线箭头，是`后台操作`，不影响更新的响应时间。



**那在这之后的读请求，要怎么处理呢？**

比如，现在要执行` select * from t where k in (k1, k2)`



如果读语句发生在更新语句后`不久`，内存中的数据都还在，那么此时的`这两个读操作`就与`系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了`，所以图中就没画出这两部分，如下图`带 change buffer 的读过程`

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/09_%E7%B4%A2%E5%BC%95_02.png)



从图中可以看到：

1. 读` Page 1 `时，直接`从内存返回`

   > WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？其实是不用的。可以看一下图中这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的

2. 要`读 Page 2 `时，需要`把 Page 2 从磁盘读入内存中`，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果



可以看到，`直到需要读 Page 2 `时，这个数据页才会被读入内存。



**对比这两个机制在提升更新性能上的收益**

* redo log 主要节省的是`随机写磁盘`的 IO 消耗（转成顺序写）
* change buffer 主要节省的则是`随机读磁盘`的 IO 消耗



## 小结

由于唯一索引用不上 change buffer 的优化机制，因此如果`业务可以接受`，从性能角度出发我建议你`优先考虑普通索引`



在业务可能无法确保数据不重复下，是否使用唯一索引

* 首先，`业务正确性优先`

  > 这篇文章的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。
  >
  > 如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。
  >
  > 这种情况下，本篇文章的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，可以给你多提供一个排查思路

* 然后，在一些`“归档库”`的场景，你是可以考虑使用普通索引的

  > 比如，线上数据只需要保留半年，然后历史数据保存在归档库。
  >
  > 这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引


