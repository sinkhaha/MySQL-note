# 复现MySQL选错索引

## 建表语句

```sql
CREATE TABLE `t` ( 
    `id` int(11) NOT NULL auto_increment,
    `a` int(11) DEFAULT NULL,
    `b` int(11) DEFAULT NULL, 
    PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`)
) ENGINE=InnoDB;
```



建立存储过程并执行`call idata()`，插入10万条数据（本地耗时约为44.03秒）

```sql
delimiter ;;
create procedure idata()
begin 
  declare i int; 
  set i=1; 
		while(i<=100000) do 
		  insert into tt values(i, i, i); 
			set i=i+1;
	  end while;
end;;
delimiter ;
call idata();
```



## 分析执行sql命中索引情况

```sql
mysql> explain select * from tt where a between 10000 and 20000;
```

结果如下

```sql
+----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | tt    | NULL       | range | a             | a    | 5       | NULL | 10001 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210629212041.png)

从结果中可见优化器选择了a为索引，符合预期



## 复现走错索引

注意：MySQL8.0.13复现不出本文中走错索引扫描全表的情况，需要用其他版本复现

| Session A                                   | Session B                                                 |
| ------------------------------------------- | --------------------------------------------------------- |
| start transaction with consistent snapshot; |                                                           |
|                                             | delete from tt;                                           |
|                                             | call idata();                                             |
|                                             | explain select * from tt where a between 10000 and 20000; |
| commit;                                     |                                                           |

这时session B 的查询语句 `select * from t where a between 10000 and 20000` 就`不会再选择索引 a `了



**步骤如下**

1. 设置开启慢日志(只对当前数据库有效，MySQL重启后失效)

```sql
set global slow_query_log=on;
```

2. 查看慢日志存储文件的位置

```sql
show variables like 'slow_query_log_file';
```

3. 开启两个MySQL实例，执行上面的语句

4. 查看慢日志文件，输出如下

```bash
/usr/local/mysql/bin/mysqld, Version: 8.0.13 (MySQL Community Server - GPL). started with:
Tcp port: 3306  Unix socket: /tmp/mysql.sock
Time                 Id Command    Argument
/usr/local/mysql/bin/mysqld, Version: 8.0.13 (MySQL Community Server - GPL). started with:
Tcp port: 3306  Unix socket: /tmp/mysql.sock
Time                 Id Command    Argument

# Time: 2021-06-29T13:38:55.134942Z
# User@Host: root[root] @ localhost []  Id:    13
# Query_time: 0.017072  Lock_time: 0.000105 Rows_sent: 10001  Rows_examined: 10001
SET timestamp=1624973935;
select * from tt where a between 10000 and 20000;
# Time: 2021-06-29T13:39:03.631562Z
# User@Host: root[root] @ localhost []  Id:    13
# Query_time: 0.013488  Lock_time: 0.000283 Rows_sent: 10001  Rows_examined: 10001
SET timestamp=1624973943;
select * from tt where a between 10000 and 20000;

# Time: 2021-06-29T13:45:57.196214Z
# User@Host: root[root] @ localhost []  Id:    13
# Query_time: 0.002059  Lock_time: 0.000000 Rows_sent: 0  Rows_examined: 0
SET timestamp=1624974357;
select * from t force index(a) where a between 10000 and 20000;
# Time: 2021-06-29T13:46:11.395209Z
# User@Host: root[root] @ localhost []  Id:    13
# Query_time: 0.000618  Lock_time: 0.000191 Rows_sent: 1  Rows_examined: 0
SET timestamp=1624974371;
explain select * from tt force index(a) where a between 10000 and 20000;
```

从慢日志中可以看到，前后执行了两次查询`select * from tt where a between 10000 and 20000;`后面执行了两次explain分析查询语句

* `Query_time`表示执行时间，单位为秒
* `Rows_examined`表示扫描的行数



可以用`force index(a)`指定查询语句强制走a索引

```sql
select * from t force index(a) where a between 10000 and 20000;
```



# 优化器的逻辑

选择索引是优化器的工作



**优化器选择索引的目的**

找到一个`最优的执行方案`，并用`最小的代价`去执行语句



在数据库里，`扫描行数`是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。



但扫描行数并不是唯一的判断标准，优化器还会结合是否`使用临时表`、`是否排序`等因素进行综合判断。



**扫描行数是怎么判断的?**

MySQL 只能根据`统计信息`来估算记录数。

这个统计信息就是`索引的“区分度”`。



显然，一个索引上不同的值越多，这个索引的区分度就越好。



而一个索引上不同的值的个数，我们称之为`“基数”（cardinality）`。也就是这个基数越大，索引的区分度越好。



`Cardinality字段`

```bash
mysql> show index from  tt;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| tt    |          0 | PRIMARY  |            1 | id          | A         |      100256 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| tt    |          1 | a        |            1 | a           | A         |      100256 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| tt    |          1 | b        |            1 | b           | A         |      100256 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
3 rows in set (0.02 sec)
```

**MySQL 是怎样得到索引的基数的呢？**

利用采样统计

```sql
mysql> explain select * from tt where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;
+----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                              |
+----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
|  1 | SIMPLE      | tt    | NULL       | range | a,b           | b    | 5       | NULL | 50128 |     1.00 | Using index condition; Using where |
+----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
1 row in set, 1 warning (0.00 sec)
```

这次优化器选择了索引 b，而 rows 字段显示需要扫描的行数是 50128



# 索引选择异常和处理

1. 采用` force index `强行选择一个正确的索引
2. 可以考虑修改sql语句，引导 MySQL 使用我们期望的索引
3. 在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引



