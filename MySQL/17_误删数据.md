#  误删数据分类

1. 使用 delete 语句误删`数据行`
2. 使用 drop table 或者 truncate table 语句误删`数据表`
3. 使用 drop database 语句误删`数据库`
4. 使用 rm 命令误删`整个MySQL实例`



# delete误删行

可以用 `Flashback工具`通过`闪回`把数据恢复回来



### Flashback恢复数据的原理

是修改 binlog 的内容，拿到原库重放



### 使用Flashback的前提

需要确保` binlog格式是row `和` binlog_row_image=FULL`



### 单个事务

具体恢复数据时，对`单个事务`做如下处理：

1. 对于 insert 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可

2. 对于 delete 语句，将 Delete_rows event 改为 Write_rows event
3. 对于 update 语句，是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可



### 多个事务

如果误操作不是一个事务，而是多个事务，则需要`将事务的顺序调过来再执行`

比如下面三个事务：

```sql
(A)delete ...
(B)insert ...
(C)update ...
```

现在要把数据库恢复回这三个事务操作之前的状态，用 Flashback 工具解析 binlog 后，`写回主库的命令`是：

```sql
(reverse C)update ...
(reverse B)delete ...
(reverse A)insert ...
```



### 恢复数据比较安全的做法

不建议直接在`主库`上执行这些操作。而是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。

> 因为一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏



### 预防删数据的两个建议

1. 把` sql_safe_updates` 参数设置为 on。这样如果忘记在 delete 或者 update 语句中写 `where 条件`，或者` where 条件里面没有包含索引字段`的话，这条语句的执行就会报错

   > 如果要把一个小表的数据全部删掉，可以在 delete 语句中加上 where 条件，比如 where id>=0。
   >
   > 
   >
   > delete 全表是很慢的，需要生成回滚日志、写 redo、写 binlog。
   >
   > 所以，从性能角度考虑，应该优先考虑使用 truncate table 或者 drop table 或 drop database命令，但这三个命令没办法通过Flashback来恢复数据，即使配置了 binlog_format=row，执行这三个命令时，记录的 binlog 还是 statement 格式，此时binlog 里就只有一个 truncate/drop 语句，这些信息是恢复不出数据的

2. 代码上线前，必须经过` SQL审计`



# 误删库/表

思路：使用`线上的全量备份 和 实时备份的binlog`的方式来恢复数据



## 前提

1. 线上有定期的`全量备份`
2. 并且有实时备份binlog



## 恢复数据的3种方法

### 方法一：mysqlbinlog方法

**流程**

假如有人`中午 12 点`误删了一个库

1. 取最近一次线上的`全量备份`，假设这个库是一天一备，上次备份是当天 0 点
2. 用全量备份`恢复`出一个`临时库`
3. 从`binlog日志备份`里，用mysqlbinlog工具解析出凌晨 0 点之后的日志
4. 把这些binlog日志，除了误删除数据的语句外，全部应用到临时库



**流程示意图如下**

数据恢复流程 -mysqlbinlog 方法，图1 

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210711205826.png)



**关于这个过程需要说明如下几点：**

1. 为了加速数据恢复，如果这个临时库上有多个数据库，可以在使用 mysqlbinlog 命令时，加上一个`–database参数`，用来`指定误删表所在的库`，避免了在恢复数据时还要应用其他库日志的情况。

2. 在应用日志的时候，需要`跳过12点误操作的那个语句的 binlog`

   * 如果原实例`没有使用 GTID 模式`，只能在应用到包含 12 点的 binlog 文件时，先用`–stop-position `参数执行到误操作之前的日志，然后再用`–start-position `从误操作之后的日志继续执行

   * 如果实例`使用了GTID模式`，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行` set gtid_next=gtid1;begin;commit; `先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 时，就会自动跳过误操作的语句




**使用mysqlbinlog方法恢复数据比较慢的2个主要原因：**

1. 如果是误删表，最好就是`只恢复出这张表`，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表 的日志
2. 用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是`单线程`



### 方法二：把临时库设置成备库

在用全量备份恢复出`临时实例`之后，将这个`临时实例`设置成`线上备库`的`从库`，流程如下：

1. 在 start slave 之前，先通过执行`﻿﻿change replication filter replicate_do_table = (tbl_name) `命令，就可以让临时库只同步误操作的表
2. 这样做也可以用上`并行复制技术`，来加速整个数据恢复过程



**这个过程的示意图如下所示，数据恢复流程 -master-slave 方法，图 2 **

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210711210556.png)

图中 binlog 备份系统到线上备库有`一条虚线`，是指如果由于时间太久，备库上已经删除了临时实例需要的 binlog 的话，可以从 binlog 备份系统中找到需要的 binlog，再放回备库中。

> 假设，当前临时实例需要的 binlog 是从 `master.000005 `开始的，但是在备库上执行 show binlogs 显示的最小的 binlog 文件是` master.000007`，意味着少了两个 binlog 文件。这时就需要`去 binlog 备份系统中找到这两个文件`。



把`之前删掉的binlog放回备库`的操作步骤，是这样的：

1. 从备份系统下载 master.000005 和 master.000006 这两个文件，放到备库的`日志目录下`
2. 打开日志目录下的 master.index 文件，在文件开头加入两行，内容分别是 “./master.000005”和“./master.000006”;
3. `重启备库`，目的是要让备库重新识别这两个日志文件
4. 现在这个备库上就有了临时库需要的所有 binlog 了，建立主备关系，就可以正常同步了



### 方法三：延迟复制备库

虽然可以通过利用`并行复制来加速恢复数据`的过程，但是这个方案仍然存在“恢复时间不可控”的问题。



如果一个库的`备份特别大`，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第 6 天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。



**缩短恢复数据需要的时间的方法**

1. 如果有非常核心的业务，不允许太长的恢复时间，可以考虑搭建`延迟复制的备库`。这个功能是 MySQL5.6 版本引入的。

> 一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了

> 延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟



比如你把 N 设置为 3600，这就代表了如果主库上有数据被误删了，并且在 1 小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行 stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。



## 建议

建议：把这个数据恢复功能做成`自动化工具`，并且经常拿出来`演练`

1. 万一出现了误删事件，能够快速恢复数据，将损失降到最小
2. 如果临时再手忙脚乱地手动操作，最后又误操作了，容易对业务造成了二次伤害



## 预防误删库/表的方法

### 建议1：账号分离

这样可以避免写错命令

1. 只给业务开发同学 `DML权限`，而不给 truncate/drop 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持
2. 即使是 DBA 团队成员，日常也都规定只使用`只读账号`，必要时才使用有更新权限的账号



### 建议2：制定操作规范

这样是避免写错要删除的表名

1. 在删除数据表之前，必须先`对表做改名操作`。然后，观察一段时间，确保对业务无影响以后再删除这张表。改表名时，要求`给表名加固定的后缀（比如加 _to_be_deleted)`，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表



# rm删除数据库实例

对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。



只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，`HA系统`就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。

这时，要做的就是在这个节点上把数据恢复回来，再接入整个集群。



当然了，现在不止是 DBA 有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个 MySQL 集群的所有节点都全军覆没。

应对这种情况，尽量把`备份跨机房，或者最好是跨城市保存`。


