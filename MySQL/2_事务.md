# 什么是事务

事务就是要保证一组数据库操作，要么全部成功，要么全部失败。



MySQL的事务支持是在`引擎层实现`的

> 原生的MyISAM 引擎不支持事务，InnoDB支持事务



# 事务的四大特性ACID

* Atomicity原子性

* Consistency一致性

* Isolation隔离性

* Durability持久性



# 隔离性Isolation与隔离级别

## 隔离级别解决的问题

隔离级别是为了解决当数据库上有`多个事务同时执行`时，出现的`脏读（dirty read）`、`不可重复读（non-repeatable read）`、`幻读（phantom read）`等问题。



隔离得越严实，效率就会越低



## SQL标准的事务隔离级别

* 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到

* 读提交（read committed）：一个事务只有在提交之后，它做的变更才会被其他事务看到

* 可重复读（repeatable read）：一个事务执行过程中`看到的数据`，总是`跟这个事务在启动时看到的数据是一致的`。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的

* 串行化（serializable ）：对于同一行记录，`“写”会加“写锁”，“读”会加“读锁”`。当出现`读写锁冲突`时，后访问的事务必须`等待`前一个事务执行完成，才能继续执行



## 数据库的隔离级别

* mysql：默认`可重复读`

* oracle：默认`读提交`



**查看数据的隔离级别**

```bash
mysql> show variables like 'transaction_isolation';

+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)
```



**修改数据的隔离级别**

```mysql
// 隔离级别值为 read uncommitted、read committed、serializable、repeatable read
set session transaction isolation level 隔离级别值；
```



## 理解隔离级别

下面借助一个例子来理解4种隔离级别：

例子：假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。

```mysql
mysql> create table T(c int) engine=InnoDB;

insert into T(c) values(1);
```



![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/03_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB_01.png)

当在`不同的隔离级别`下，事务 A 会有哪些不同的返回结果，也就是图里` V1、V2、V3 的返回值`分别是什么

* 若隔离级别是`“读未提交”`， 则 V1的值就是2

  > 这时事务B虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2

* 若隔离级别是`“读提交”`，则 V1是1，`V2 的值是 2`

  > 事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2

* 若隔离级别是`“可重复读”`，`则 V1、V2 是 1`，V3 是 2

  > 之所以 V2 还是 1，遵循的就是这个要求：`事务在执行期间看到的数据前后必须是一致的`

* 若隔离级别是`“串行化”`，则在事务 B 执行“将 1 改成 2”时，`会被锁住`。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。



#### 一致性视图

在实现上，数据库里面会`创建一个视图`，访问的时候以`视图的逻辑结果`为准

* 在“读未提交”隔离级别下，直接返回记录上的最新值，`没有视图概念`
* 在“读提交”隔离级别下，这个视图是`在每个 SQL 语句开始执行的时候创建的`
* 在“可重复读”隔离级别下，这个视图是在`事务启动时创建的`，整个事务存在期间都用这个视图
* 在“串行化”隔离级别下，直接用`加锁的方式`来避免并行访问



> 因为Oracle 数据库的`默认隔离级别`其实就是`“读提交”`，所以对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，要记得将 MySQL 的隔离级别设置为“读提交”



**每种隔离级别都有自己的使用场景，要根据自己的业务情况来定**

如什么时候需要“可重复读”的场景呢？下面举一个数据校对逻辑的案例。

例1：假设你在管理一个个人银行账户表。一个表存了`账户余额`，一个表存了`账单明细`。到了月底你要做`数据校对`，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，`即使有用户发生了一笔新的交易，也不影响你的校对结果`。

这时使用`“可重复读”`隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响



# 回滚日志undo log

undo log是事务隔离的实现，`变更记录`记录在`redo log`，`回滚记录`记录`在undo log`



**下面以`可重复读`隔离级别为例：**

在 MySQL 中，实际上每条记录在`更新`时都会同时记录一条`回滚操作`。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。



假设一个值`从 1 被按顺序改成了 2、3、4`，在`回滚日志`里面就会有类似下面的记录

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/03_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB_02.png)



`当前值是 4`，但是在查询这条记录时，`不同时刻启动的事务会有不同的 read-view视图`

如图，在`视图 A、B、C 里面`，这一个记录的值分别是 1、2、4，`同一条记录在系统中可以存在多个版本`，就是数据库的`多版本并发控制（MVCC）`。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。



在可重复读隔离级别下，比如对于初始值 4，存在事务 A、B、C、和 X，其中` X 最先启动` 之后` C、B、A 分别依次执行 -1` 且 `commit `则该数据的版本链就如上图所示。对于 X，会沿着版本链回溯，找到属于它应该看见的值：4



在可重复读隔离级别下，分别开启事务A和B，如果A先更新一条数据，`A事务还没提交时，如果此时事务B也更新同一条数据，此时会被锁住`，等待A事务提交了B才能执行更新。



同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。



**回滚日志在什么时候删除呢？**

在不需要的时候才删除

> 也就是说，系统会判断，当`没有事务`再需要用到这些回滚日志时，回滚日志会被删除

什么时候才不需要了呢？

> 就是当系统里`没有比这个回滚日志更早的 read-view` 时



**建议：尽量不要使用长事务?**

长事务意味着系统里面会存在`很老的事务视图`。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务`提交之前`，数据库里面它可能用到的回滚记录都必须保留，这就会`导致大量占用存储空间`



除了对回滚段的影响，长事务还`占用锁资源`，也可能拖垮整个库

* MySQL5.6之前，undo表空间位于`共享表空间的回滚段`中，共享表空间的默认的名称是`ibdata`，位于`数据文件目录`中。即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了`清理回滚段，重建整个库。`

* MySQL5.6之后，undo表空间可以`配置成独立的文件`，但是提前需要在配置文件中配置，完成`数据库初始化`后生效且`不可改变undo log文件的个数`，如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。

MySQL5.7之后的独立undo 表空间配置参数如下

* innodb_undo_directory = /data/undospace/  ：undo独立表空间的存放目录
* innodb_undo_logs = 128 ：回滚段为128KB
* innodb_undo_tablespaces = 4 ：指定有4个undo log文件



默认情况下undo文件是保持在`共享表空间`的，也即`ibdatafile文件`中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在`共享表空间`中的。因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。因此，mysql5.7之后的`“独立undo 表空间”`的配置就显得很有必要了。



如果undo使用的`共享表空间`，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为`MySQL的数据目录下面`，其属性由参数`innodb_data_file_path`配置

```bash
mysql> show variables like '%innodb_data_file_path%';
+-----------------------+------------------------+
| Variable_name         | Value                  |
+-----------------------+------------------------+
| innodb_data_file_path | ibdata1:12M:autoextend |
+-----------------------+------------------------+

```



# 事务的2种启动方式

MySQL 的事务启动方式有以下2种：

1. 显式启动事务语句，` begin 或 start transaction`。配套的提交语句是 `commit`，回滚语句是 `rollback`

2. `set autocommit=0`，会将这个线程的`自动提交关掉`

   > 意味着如果`只执行一个select 语句，这个事务就启动了`，而且`并不会自动提交`。这个事务持续存在直到你`主动执行 commit 或 rollback 语句`，或者断开连接

  

**查看当前自动提交状态的命令**

ON为已开启自动提交

```bash
mysql> show variables like 'autocommit';

+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)

```



有些客户端连接框架会`默认`连接成功后先执行一个 `set autocommit=0 `的命令

> 这就导致接下来的查询都在事务中，如果是`长连接`，就导致了`意外的长事务`

对于一个需要`频繁使用事务`的业务，如果set autocommit=0的方式，每个事务在开始时都`不需要主动执行一次 “begin”`，减少了语句的交互次数。



**` commit work and chain `语法**

在 `autocommit 为 1` 的情况下，用` begin 显式启动的事务`，如果执行 commit 则提交事务。如果执行 commit work and chain，则是`提交事务并自动启动下一个事务`，这样也省去了再次执行 begin 语句的开销。



你可以在` information_schema 库`的 `innodb_trx `这个表中`查询长事务`，比如下面这个语句，用于`查找持续时间超过 60s 的事务`

```mysql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) > 60;
```



