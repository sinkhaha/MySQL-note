# 背景

创建表t，表中有`主键id `和`索引 c`，初始化语句在表中插入了 6 行数据

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

-- 插入了 6 行数据
insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```



下面的语句是怎么加锁的，又是什么时候释放的？

```sql
begin;
select * from t where d=5 for update;
commit;
```

这个语句会命中 d=5这行，对应的主键 id=5，`id=5 这一行会加一个写锁`，这个写锁在执行 commit 语句时释放。



**由于`字段d上没有索引`，因此这条查询语句会做`全表扫描`。那么，其他被扫描到的，但是不满足条件的记录，会不会被加锁呢？**

 

InnoDB 的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都是设定在**可重复读**隔离级别下。



# 什么是幻读

## 先假设一个场景

先假设只在 id=5 这一行加锁，而其他行的不加锁的话，会怎么样

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709221313.png)

session A 里执行了三次查询，分别是 Q1、Q2 和 Q3。它们的 SQL 语句相同，都是` select * from t where d=5 for update`，使用的是`当前读`，并且加上`写锁`。



**session A这三条 SQL 语句分别会返回什么结果**

1. Q1 只返回 id=5 这一行
2. 在 T2 时刻，session B 把 id=0 这一行的 d 值改成了 5，因此 T3 时刻 Q2 查出来的是 id=0 和 id=5 这两行
3. 在 T4 时刻，session C 又插入一行（1,1,5），因此 T5 时刻 Q3 查出来的是 id=0、id=1 和 id=5 的这三行



## 幻读

幻读指的是`一个事务在前后两次查询同一个范围`时，后一次查询看到了前一次查询没有看到的行。Q3 读到 id=1 这一行的现象，被称为“幻读”。



1. 幻读在“当前读”下才会出现，在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的
2. 幻读仅专指“新插入的行”，上面 session B 的修改语句，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读



# 幻读有什么问题（假设）

### 首先是语义上的

**前提**

假设只在id=5这一行加锁



**在假设下会出现的问题**

session A 在 `T1 时刻`声明了“我要把`所有d=5的行`锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了(没办法锁住所有d=5的行)



**举例说明假设下出现的问题**

举例说明 Q1 的加锁声明把破坏了，看看会出现什么现象

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709222101.png)

1. session B 的第二条语句` update t set c=5 where id=0`，语义是“我把 id=0、d=5 这一行的 c 值，改成了 5”
2. 由于在 T1 时刻，session A 还只是给 id=5 这一行加了行锁， `并没有给 id=0 这行加上锁`

3. 因此，session B 在 T2 时刻，`是可以执行这两条 update 语句的`。这样，就破坏了 session A 里 Q1 语句要锁住`所有 d=5 的行`的加锁声明。



session C 也是一样的道理，对 id=1 这一行的修改，也是破坏了 Q1 的加锁声明



### 数据一致性的问题

锁的设计是为了保证数据的一致性。

1. `数据库内部数据状态`在此刻的一致性
2. `数据和日志在逻辑`上的一致性



**前提**

假设只在id=5这一行加锁



**在假设下会出现的问题**

数据不一致问题



**举例说明假设下出现的问题**

给 session A 在 T1 时刻再加一个更新语句，即：`update t set d=100 where d=5`

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709222441795.png)



session A 声明说`“要给 d=5 的语句加上锁”`，就是为了要更新数据，新加的这条 update 语句就是把它认为加上了锁的这一行的 d 值修改成了 100



**分析数据不一致出现的流程**

数据库里的结果（没问题）

1. 经过 T1 时刻，id=5 这一行变成` (5,5,100)`，当然这个结果最终是在 T6 时刻正式提交的 

2. 经过 T2 时刻，id=0 这一行变成` (0,5,5)`

3. 经过 T4 时刻，表里面多了一行 `(1,5,5)`

4. 其他行跟这个执行序列无关，保持不变

   

 binlog 里面的内容（有问题）

1. T2 时刻，session B 事务提交，写入了两条语句
2. T4 时刻，session C 事务提交，写入了两条语句
3. T6 时刻，session A 事务提交，写入了` update t set d=100 where d=5 `这条语句



统一放到一起的话如下

```sql
update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/

insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/
```

这个语句序列，不论是`拿到备库去执行`，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了` (0,5,100)、(1,5,100) 和 (5,5,100)`

也就是id=0 和 id=1 这两行，发生了数据不一致。这个问题很严重，是不行的。



**这个数据不一致到底是怎么引入的？**

这是`假设“select * from t where d=5 for update `这条语句`只给 d=5 这一行`，也就是` id=5 的这一行加锁”导致的`



**怎么改**

需要把扫描过程中碰到的行，也都加上写锁

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709223140728.png)

1. 由于 session A 把`所有的行`都加了写锁，所以 session B 在执行第一个 update 语句时就被锁住了
2. 需要等到 T6 时刻 session A 提交以后，session B 才能继续执行



对于 id=0 这一行，在数据库里的最终结果还是` (0,5,5)`。在 binlog 里面，执行序列是这样的：

```sql
insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/

update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/
```

按照日志顺序执行，id=0 这一行的最终结果也是 (0,5,5)。所以，id=0 这一行的问题解决了。



但id=1 这一行，在数据库里面的结果是 (1,5,5)，而根据 binlog 的执行结果是 (1,5,100)，也就是说`幻读的问题还是没有解决`。



**不存在的记录加不了锁导致问题**

为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了 id=1 这一行的插入和更新呢？

原因很简单。在 T3 时刻，我们`给所有行加锁的时候`，`id=1 这一行还不存在，不存在也就加不上锁`。



也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因



# InnoDB如何解决幻读

### 产生幻读的原因

`行锁只能锁住行`，但是`新插入`记录这个动作，要`更新的是记录之间的“间隙”`



### 间隙锁

为了解决幻读问题，InnoDB 只好引入新的锁，也就是`间隙锁 (Gap Lock)`。



间隙锁，锁的就是`两个值之间的空隙`。



比如表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。表 t 主键索引上的行锁和间隙锁如下

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709224643473.png)

当执行 `select * from t where d=5 for update`时，就不止是给数据库中`已有的 6 条数据加上了行锁`，还`同时加了 7 个间隙锁`。这样就确保了无法再插入新的记录

也就是说这时，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。



**数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体**



### 行锁跟行锁冲突

行锁：分成读锁和写锁。



这两种类型行锁的冲突关系

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709225026.png)

说明跟行锁有冲突关系的是“另外一个行锁”



### 间隙锁跟什么冲突

**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁跟间隙锁之间都不存在冲突关系**。



举个例子：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709225346.png)

这里` session B 并不会被堵住`。因为`表 t 里并没有 c=7 这个记录`，因此 session A 加的是`间隙锁 (5,10)`。而 session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：`保护这个间隙，不允许插入值。但，它们之间是不冲突的`。



### next-key lock

**next-key lock解决了幻读问题**

`间隙锁`和`行锁`合称 next-key lock，每个 next-key lock 是`前开后闭区间`。

>备注：文章中，如果没有特别说明，我们把间隙锁记为开区间，把 next-key lock 记为前开后闭区间



表 t 初始化以后，如果用` select * from t for update 要把整个表所有记录锁起来`，就形成了 7 个 `next-key lock`，分别是` (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]`

> 因为 +∞是开区间。实现上，InnoDB 给每个索引加了一个不存在的最大值 supremum，这样才符合我们前面说的“都是前开后闭区间”。



间隙锁和 next-key lock 的引入，解决了幻读的问题，但同时也带来了一些“困扰”。



**举例**

有个业务逻辑如下：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据



代码如下：

```sql
begin;
select * from t where id=N for update;

/*如果行不存在*/
insert into t values(N,N,N);
/*如果行存在*/
update t set d=N set id=N;

commit;
```

可能你会说，这个不是` insert … on duplicate key update `就能解决吗？但其实在有多个唯一键时，这个方法是不能满足需求的。



现在，我们就只讨论这个逻辑。这个逻辑一旦有并发，就会碰到`死锁`。这个逻辑每次操作前用 `for update `锁起来，已经是最严格的模式了，怎么还会有死锁呢？



用两个 session 来模拟并发，并假设 N=9

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709225927078.png)

其实都不需要用到后面的 update 语句，就已经形成`死锁`了。

按语句执行顺序来分析一下：

1. session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上`间隙锁 (5,10)`
2. session B 执行 select … for update 语句，同样会`加上间隙锁 (5,10)`，间隙锁之间不会冲突，因此这个语句可以执行成功
3. session B 试图插入一行 (9,9,9)，`被 session A 的间隙锁挡住`了，只好进入等待
4. session A 试图插入一行 (9,9,9)，`被 session B 的间隙锁挡住`了



至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。



**缺点**

间隙锁的引入，可能会`导致同样的语句锁住更大的范围`，这其实是`影响了并发度`的。



### 存在间隙锁的前提

间隙锁是在`可重复读隔离级别`下才会生效的。

> 如果把隔离级别设置为`读提交`的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。此时读提交下操作数据的锁范围更小（没有间隙锁）



# 间隙锁加锁规则

## 规则的前提说明

这个规则只限于截止到现在的最新版本，即 

1. 5.x 系列， <=5.7.24
2. 8.0 系列，<=8.0.13



## 加锁规则

间隙锁在`可重复读`隔离级别下才有效，所以本文所讲的默认是可重复读隔离级别



可重复读隔离级别遵守`两阶段锁协议`，所有加锁的资源，都是在`事务提交或者回滚`时才释放的



### 两个'原则'

1. 原则 1：加锁的基本单位是 `next-key lock`，`next-key lock` 是`前开后闭区间`
2. 原则 2：查找过程中`访问到的对象（如索引）`才会加锁

> 访问到的对象，要从底层的结构来看待，而不是数据表的一行，而是如索引、主键索引之类的底层数据结构。 
>
> 例如普通索引和主键索引，如果访问的是普通索引，而且通过索引覆盖并不需要回表查主键索引，那么主键索引上是没有加任何锁的，因为并没有访问主键索引树上的“对象”



### 两个'优化'

1. 优化 1：`索引`上的等值查询，给`唯一索引`加锁时，`next-key lock 退化为行锁`
2. 优化 2：`索引`上的等值查询，如果不是唯一索引，`向右遍历`时且`最后一个值不满足等值条件`的时候，`next-key lock 退化为间隙锁`



###  一个'bug'

1. 一个 bug：唯一索引上的`范围查询`会访问到`不满足条件的第一个值为止`

> 范围查询：无论是否是唯一索引，范围查询都需要访问到不满足条件的第一个值为止

> mysql 8.0.18 开始，修复了这个 bug



## 建表语句

表 t 的建表语句和初始化语句

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

-- 插入6条记录
insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```



## 案例一：等值查询-间隙锁

`等值条件`操作间隙的例子：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210710132627779.png)

session A，表 t 中没有` id=7 `的记录，用加锁规则分析如下：

1. 根据`原则 1`，加锁单位是 next-key lock，session A 加锁范围就是 `(5,10]`
2. 根据`优化 2`，这是一个`等值查询 (id=7)`，而 `id=10 不满足查询条件`，next-key lock 退化成`间隙锁`
3. 因此session A最终加锁的范围是 `(5,10)`



所以，session B 要往`这个间隙里面插入 id=8 的记录会被锁住`，但是 `session C 修改 id=10 这行是可以的`

> 是因为(8,8,8)中的第一个值id=8导致的，不是因为c=8或者d=8导致的。这里是因为`主键索引id上有间隙锁(5,10)`，只要是id=8，此时不管c和d的值是多少，都会被阻塞插入




## 案例二：非唯一索引-等值锁

关于`覆盖索引的锁`例子：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710133021.png)

session A `lock in share mode`给`索引 c 上 c = 5 的这一行`加上`读锁`

1. 根据`原则 1`，加锁单位是 next-key lock，因此会给` (0,5]`加上 next-key lock
2. 注意 c 是`普通索引`，因此仅访问 c=5 这一条记录不能马上停下来，需要`向右遍历`，`查到 c=10 才停止`。根据`原则 2`，访问到的都要加锁，因此要给` (5,10]`加 next-key lock
3. 根据`优化 2`：等值判断，向右遍历，最后一个值10不满足 c=5 这个等值条件，因此退化成间隙锁` (5,10)`
4. 根据`原则 2` ，只有访问到的对象才会加锁，这个查询使用`覆盖索引`，并`不需要访问主键索引`，所以`主键索引上没有加任何锁`，这就是为什么 session B 的 update 语句可以执行完成



但 session C 要插入一个` (7,7,7)` 的记录，就会被` session A 的间隙锁 (5,10) 锁住`。

> 因为c=7这一行已经被session A锁住了



**注意**

在这个例子中，`lock in share mode 只锁覆盖索引`，但是如果是` for update `就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给`主键索引`上满足条件的行加上行锁。



### 锁是加在索引上的

这个例子说明，`锁是加在索引上的`；



如果要用 lock in share mode 来给`行加读锁避免数据被更新`的话，就必须得`绕过覆盖索引的优化`，在`查询字段中加入索引中不存在的字段`。

比如，将 session A 的查询语句改成` select d from t where c=5 lock in share mode`，此时会回表去查主键索引，访问到的主键索引也会加锁



## 案例三：主键索引-范围锁

**问题**

对于我们这个表 t，下面这两条查询语句，加锁范围相同吗？

```sql
select * from t where id=10 for update;

select * from t where id>=10 and id<11 for update;
```

它们并不完全等价。在逻辑上，这两条查语句肯定是等价的，但是它们的`加锁规则不太一样`。



关于范围查询的例子，让 session A 执行第二个查询语句，来看看加锁效果

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710133818.png)



**用加锁规则分析一下 session A 会加什么锁**

1. 开始执行时，要找到第一个` id=10`的行，此时是` next-key lock(5,10]`。 根据`优化 1`， 主键 id 上的`等值条件`，退化成`行锁`，只加了` id=10 `这一行的行锁
2. `范围查找`就往后继续找，找到 id=15 这一行停下，因此需要加 `next-key lock(10,15]`

3. 所以，session A 这时候锁的范围就是`主键索引上`，`行锁 id=10 和 next-key lock(10,15]`。这样，session B 和 session C 的结果你就能理解了。



**注意**

首次 session A 定位查找 id=10 的行时，是`当做等值查询来判断的`，而向右扫描到 id=15 的时候，用的是`范围查询判断`



## 案例四：非唯一索引-范围锁

与案例三的区别是，案例四中查询语句的 where 部分用的是`字段 c`

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710134320.png)

**session A 用`字段 c `来判断，加锁规则跟案例三唯一的不同是：**

1. 在第一次用 c=10 定位记录时，索引 c 上加了` (5,10]这个 next-key lock `后，由于索引 c 是非唯一索引，`没有优化规则`，也就是说不会变为行锁，因此最终 sesion A 加的锁是，索引 c 上的` (5,10] `和` (10,15] `这两个 next-key lock



所以sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。



这里需要扫描到 c=15 才停止扫描，是合理的，因为 `InnoDB 要扫到 c=15，才知道不需要继续往后找了`



## 案例五：唯一索引-范围锁bug

关于加锁规则中 bug 的例子

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210710134511986.png)



1. session A 是一个范围查询，按照`原则 1 `的话，应该是`索引 id `上只加` (10,15]`这个 next-key lock，并且因为` id 是唯一键`，所以循环判断到` id=15 这一行就应该停止`了

2. 但是实现上，`InnoDB 会往前扫描到第一个不满足条件的行为止`，也就是` id=20`。而且由于这是个`范围扫描`，因此索引 id 上的` (15,20]`这个 next-key lock 也会被锁上



所以session B 要更新 id=20 这一行，是会被锁住的。

同样地，session C 要插入 id=16 的一行，也会被锁住。



照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为`扫描到 id=15，就可以确定不用往后再找了`。但实现上还是这么做了，因此这是个 bug。



## 案例六：非唯一索引上存在"等值"的例子

为了更好地说明“间隙”这个概念的例子。给表 t 插入一条新记录

```sql
insert into t values(30,10,30);
```



新插入的这一行` c=10`，也就是说现在表里有`两个 c=10 的行`。

那么，这时索引 c 上的间隙是什么状态了呢？你要知道，由于`非唯一索引上包含主键的值`，所以是`不可能存在“相同”的两行的`。



**非唯一索引等值的例子**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710134803.png)

虽然有两个 c=10，但是它们的`主键值 id 是不同的`（分别是 10 和 30），因此这两个 c=10 的记录之间，也是`有间隙`的。

> 图中画出了索引 c 上的主键 id。为了跟间隙锁的开区间形式进行区别，我用` (c=10,id=30) `这样的形式，来表示索引上的`一行`



这次用 delete 语句来验证。

注意，delete 语句加锁的逻辑，其实跟` select ... for update` 是类似的，也就是在文章开始总结的两个“原则”、两个“优化”和一个“bug”

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710134914.png)

1. session A 在遍历时，先访问第一个 c=10 的记录。同样地，根据`原则 1`，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。

2. 然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据`优化 2`，这是一个`等值查询`，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。



也就是说，这个 delete 语句在`索引 c `上的加锁范围，就是下图中蓝色区域覆盖的部分

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135034.png)





## 案例七：limit 语句加锁

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135101.png)



这个例子里，session A 的 delete 语句加了 limit 2

表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。



这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。



因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135128.png)



(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此 insert 语句插入 c=12 是可以执行成功的。



在删除数据的时候`尽量加 limit`。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围



## 案例八：一个死锁的例子

再看一个案例用来说明：next-key lock 实际上是间隙锁和行锁加起来的结果



![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135217.png)

**按时间顺序来分析一下为什么是这样的结果**

1. session A 启动事务后执行查询语句加 lock in share mode，在`索引 c `上加了 `next-key lock(5,10] `和`间隙锁 (10,15)`
2. session B 的 update 语句也要在`索引 c `上加 `next-key lock(5,10]` ，进入锁等待
3. 然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了`死锁`，InnoDB 让 session B 回滚



**你可能会问，session B 的 next-key lock 不是还没申请成功吗？**

其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。



也就是说，我们在分析加锁规则时可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成`间隙锁`和`行锁`两段来执行的。

