

# 背景

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

这个表除了`主键 id `外，还有一个`索引 c`，初始化语句在表中插入了 6 行数据



下面的语句是怎么加锁的，又是什么时候释放的？

```sql
begin;
select * from t where d=5 for update;
commit;
```

这个语句会`命中 d=5 `这行，对应的主键 id=5，因此在 select 语句执行完成后，`id=5 这一行会加一个写锁`，而且由于`两阶段锁协议`，这个写锁会在执行 commit 语句的时候释放。



由于`字段 d 上没有索引`，因此这条查询语句会做`全表扫描`。

那么，其他被扫描到的，但是不满足条件的 5 行记录上，会不会被加锁呢？

 

InnoDB 的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都是设定在可重复读隔离级别下。



# 什么是幻读

## 先假设一个场景

先假设只在 id=5 这一行加锁，而其他行的不加锁的话，会怎么样

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709221313.png)

session A 里执行了三次查询，分别是 Q1、Q2 和 Q3。

它们的 SQL 语句相同，都是` select * from t where d=5 for update`。

这个语句查所有 d=5 的行，因为这三个查询都是加了 `for update`，使用的是`当前读`，并且加上`写锁`，而当前读的规则，就是要能读到所有已经提交的记录的最新值。



**session A这三条 SQL 语句分别会返回什么结果**

1. Q1 只返回 id=5 这一行
2. 在 T2 时刻，session B 把 id=0 这一行的 d 值改成了 5，因此 T3 时刻 Q2 查出来的是 id=0 和 id=5 这两行
3. 在 T4 时刻，session C 又插入一行（1,1,5），因此 T5 时刻 Q3 查出来的是 id=0、id=1 和 id=5 的这三行



## 幻读

幻读指的是一个事务在前后两次查询`同一个范围`时，后一次查询看到了前一次查询没有看到的行。

Q3 读到 id=1 这一行的现象，被称为“幻读”。



**对“幻读”做一个说明**

1. 在可重复读隔离级别下，`普通的查询是快照读`，是不会看到别的事务插入的数据的。因此，`幻读在“当前读”下才会出现`
2. 上面 session B 的修改结果，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读。`幻读仅专指“新插入的行”`



# 幻读有什么问题（假设）

### 首先是语义上的

**前提**

假设只在id=5这一行加锁



**在假设下会出现的问题**

session A 在 `T1 时刻`声明了`“我要把所有 d=5 的行锁住，不准别的事务进行读写操作”`。而实际上，这个语义被破坏了



**举例说明假设下出现的问题**

举例说明 Q1 的加锁声明把破坏了，看看会出现什么现象

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709222101.png)

1. session B 的第二条语句` update t set c=5 where id=0`，语义是`“我把 id=0、d=5 这一行的 c 值，改成了 5”`
2. 由于在 T1 时刻，session A 还`只是给 id=5 这一行加了行锁`， `并没有给 id=0 这行加上锁`

3. 因此，session B 在 T2 时刻，`是可以执行这两条 update 语句的`。这样，就破坏了 session A 里 Q1 语句`要锁住所有 d=5 的行的加锁声明`。



session C 也是一样的道理，对 id=1 这一行的修改，也是破坏了 Q1 的加锁声明



### 数据一致性的问题

锁的设计是为了保证数据的一致性。

1. `数据库内部数据状态`在此刻的一致性
2. `数据和日志在逻辑`上的一致性



**前提**

假设只在id=5这一行加锁



**在假设下会出现的问题**

数据不一致问题



**举例说明假设下出现的问题**

举例说明，我给 session A 在 T1 时刻再加一个更新语句，即：`update t set d=100 where d=5`

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709222441795.png)



update 的加锁语义和` select …for update `是一致的，所以这时加上这条 update 语句也很合理。

session A 声明说`“要给 d=5 的语句加上锁”`，就是为了要更新数据，新加的这条 update 语句就是把它认为加上了锁的这一行的 d 值修改成了 100



**分析数据不一致出现的流程**

数据库里的结果（没问题）

1. 经过 T1 时刻，id=5 这一行变成` (5,5,100)`，当然这个结果最终是在 T6 时刻正式提交的 

2. 经过 T2 时刻，id=0 这一行变成` (0,5,5)`

3. 经过 T4 时刻，表里面多了一行 `(1,5,5)`

4. 其他行跟这个执行序列无关，保持不变

   

 binlog 里面的内容（有问题）

1. T2 时刻，session B 事务提交，写入了两条语句
2. T4 时刻，session C 事务提交，写入了两条语句
3. T6 时刻，session A 事务提交，写入了` update t set d=100 where d=5 `这条语句



统一放到一起的话如下

```sql
update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/

insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/
```

这个语句序列，不论是`拿到备库去执行`，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了` (0,5,100)、(1,5,100) 和 (5,5,100)`

也就是id=0 和 id=1 这两行，发生了数据不一致。这个问题很严重，是不行的。



**这个数据不一致到底是怎么引入的？**

这是`假设“select * from t where d=5 for update `这条语句`只给 d=5 这一行`，也就是` id=5 的这一行加锁”导致的`



**怎么改**

把扫描过程中碰到的行，也都加上写锁

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709223140728.png)

1. 由于 session A 把`所有的行`都加了写锁，所以 session B 在执行第一个 update 语句时就被锁住了
2. 需要等到 T6 时刻 session A 提交以后，session B 才能继续执行



对于 id=0 这一行，在数据库里的最终结果还是` (0,5,5)`。在 binlog 里面，执行序列是这样的：

```sql
insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/

update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/
```

按照日志顺序执行，id=0 这一行的最终结果也是 (0,5,5)。所以，id=0 这一行的问题解决了。



但id=1 这一行，在数据库里面的结果是 (1,5,5)，而根据 binlog 的执行结果是 (1,5,100)，也就是说`幻读的问题还是没有解决`。



**不存在的记录加不了锁导致问题**

为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了 id=1 这一行的插入和更新呢？

原因很简单。在 T3 时刻，我们`给所有行加锁的时候`，`id=1 这一行还不存在，不存在也就加不上锁`。



也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因



# InnoDB如何解决幻读

### 产生幻读的原因

`行锁只能锁住行`，但是`新插入`记录这个动作，要`更新的是记录之间的“间隙”`



### 间隙锁

为了解决幻读问题，InnoDB 只好引入新的锁，也就是`间隙锁 (Gap Lock)`。



间隙锁，锁的就是`两个值之间的空隙`。



比如表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。表 t 主键索引上的行锁和间隙锁如下

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709224643473.png)

当执行 `select * from t where d=5 for update`时，就不止是给数据库中`已有的 6 个记录加上了行锁`，还`同时加了 7 个间隙锁`。这样就确保了无法再插入新的记录

也就是说这时，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。



数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体



### 行锁跟行锁冲突

行锁：分成读锁和写锁。



这两种类型行锁的冲突关系

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709225026.png)

说明跟行锁有冲突关系的是“另外一个行锁”



### 间隙锁跟什么冲突

**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系**。



举个例子：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709225346.png)

这里` session B 并不会被堵住`。因为`表 t 里并没有 c=7 这个记录`，因此 session A 加的是`间隙锁 (5,10)`。而 session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：`保护这个间隙，不允许插入值。但，它们之间是不冲突的`。



### next-key lock

**next-key lock解决了幻读问题**

`间隙锁`和`行锁`合称 next-key lock，每个 next-key lock 是`前开后闭区间`。

>备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把 next-key lock 记为前开后闭区间



表 t 初始化以后，如果用` select * from t for update 要把整个表所有记录锁起来`，就形成了 7 个 `next-key lock`，分别是` (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]`

> 因为 +∞是开区间。实现上，InnoDB 给每个索引加了一个不存在的最大值 supremum，这样才符合我们前面说的“都是前开后闭区间”。



间隙锁和 next-key lock 的引入，解决了幻读的问题，但同时也带来了一些“困扰”



**举例**

有个业务逻辑如下：

任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据



代码如下：

```sql
begin;
select * from t where id=N for update;

/*如果行不存在*/
insert into t values(N,N,N);
/*如果行存在*/
update t set d=N set id=N;

commit;
```

可能你会说，这个不是` insert … on duplicate key update `就能解决吗？但其实在有多个唯一键的时候，这个方法是不能满足需求的。至于为什么，我会在后面的文章中再展开说明。



现在，我们就只讨论这个逻辑。这个逻辑一旦有并发，就会碰到`死锁`。这个逻辑每次操作前用 `for update `锁起来，已经是最严格的模式了，怎么还会有死锁呢？



用两个 session 来模拟并发，并假设 N=9

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709225927078.png)

其实都不需要用到后面的 update 语句，就已经形成`死锁`了。

按语句执行顺序来分析一下：

1. session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上`间隙锁 (5,10)`
2. session B 执行 select … for update 语句，同样会`加上间隙锁 (5,10)`，间隙锁之间不会冲突，因此这个语句可以执行成功
3. session B 试图插入一行 (9,9,9)，`被 session A 的间隙锁挡住`了，只好进入等待
4. session A 试图插入一行 (9,9,9)，`被 session B 的间隙锁挡住`了



至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。



**缺点**

间隙锁的引入，可能会`导致同样的语句锁住更大的范围`，这其实是`影响了并发度`的。



### 存在间隙锁的前提

间隙锁是在`可重复读隔离级别`下才会生效的。

> 如果把隔离级别设置为`读提交`的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。此时读提交下操作数据的锁范围更小（没有间隙锁）

