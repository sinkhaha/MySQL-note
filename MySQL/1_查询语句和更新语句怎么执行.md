# 一、查询语句是怎么执行的

## MySQL基本架构示意图

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/MySQLStudy/mysql%E7%9A%84%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png)




1. Server层

   > * 核心服务功能
   > * 所有内置函数(如日期、时间、数学和加密函数等)
   > * 所有跨存储引擎功能(如存储过程、触发器、视图)

2. 存储引擎层

   > 负责数据的存储和提取(插件式架构，有 InnoDB(MySQL5.5.5版本默认)、MyISAM、Memory 等多个存储引擎)



## 查看表存储引擎的3种方式

1. `show create table 表名`
2. `show table status from 库名 where name='表名'`
3. ``select * from information_schema.tables where table_schema='库名' and table_name='表名'`



## MySQL的5个组件

### 一、连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接

#### 连接过程

1. 输入MySQL连接命令
2. tcp握手建立连接 
3. 认证帐密 
4. 查权限(权限表)

>注意：对用户的权限做了修改后，只有再新建的连接才会使用新的权限设置，不会影响已经存在连接的权限

5. 连接完成

>如果此时没操作，此连接就处于空闲状态。wait_timeout参数控制空闲连接断开时间，默认8小时

```bash
// 查看连接命令，Command列为Sleep表示为空闲连接
show processlist;

// 输出如下 ,此时有一个空闲连接
+----+-----------------+-----------------+--------+---------+------+------------------------+------------------+
| Id | User            | Host            | db     | Command | Time | State                  | Info             |
+----+-----------------+-----------------+--------+---------+------+------------------------+------------------+
|  4 | event_scheduler | localhost       | NULL   | Daemon  | 1185 | Waiting on empty queue | NULL             |
|  8 | root            | localhost:49663 | NULL   | Sleep   | 1037 |                        | NULL             |
|  9 | root            | localhost       | mytest | Query   |    0 | starting               | show processlist |
+----+-----------------+-----------------+--------+---------+------+------------------------+------------------+
```

```bash
// 运行命令，查看wait_timeout控制空闲连接断开的时间参数
show variables like 'wait_timeout';

// 输出如下  28800秒即8小时
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| wait_timeout  | 28800 |
+---------------+-------+

```



#### 数据库的长连接和短连接

* 长连接客户端持续有请求，一直使用同一个连接

>缺点：内存占用过大，因为MySQL在执行过程中使用的内存的管理是在连接对象中的，这些资源会在断开连接时才释放，可能会导致MySQL异常重启

* 短连接：每次执行完很少的几次查询就断开连接，下次查询再重新建立一个

>缺点：建立连接的过程通常比较复杂，不适宜反复创建

**怎样解决长连接占用内存过大问题**

1. `定期断开`长连接 或者 程序里面`判断执行过一个占用内存的大查询后`断开连接，等要查询再重连
2. MySQL5.7及以后版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection` 来重新`初始化连接资源`，这个过程不需要重连和重新做权限验证



### 二、查询缓存(不建议用)

> MySQL8.0已经彻底删除了该功能

**流程**

1. 执行select语句
2. 先查缓存，因为执行完查询语句MySQl会`缓存查询过的语句`(key-value形式，key是语句的hash值，value是查询结果)
3. 缓存存在直接返回，不存在则执行后面的阶段



**查询缓存的缺点**

1. 对于更新比较频繁的数据库，命中率太低

2. 容易缓存失效频繁

   > 只要有对一个表的`更新`，这个表上所有的查询缓存都会被清空

3. 会额外耗费一次hash计算 

4. 耗费内存




**MySQL8.0之前的版本按需开启查询缓存**

将参数 `query_cache_type` 设置成 `DEMAND`，则默认都不使用查询缓存。

而对于要使用查询缓存的语句，可以用 `SQL_CACHE` 显式指定，如

```mysql
select SQL_CACHE * from T where ID=10；
```



### 三、分析器

如果没有命中查询缓存，就要开始真正执行语句了

#### 1. 词法分析

>识别语句的每个单词代表什么意思
>
>从输入的"select"识别出来这是一个查询语句，把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”

#### 2. 语法分析

>判断输入的这个 SQL 语句是否满足 MySQL 语法，如果不正确，会报错`You have an error in your SQL syntax`

例如：

```mysql
// 从报错得知要关注的是紧接“use near”的内容
mysql> select * from t where ID=1;

ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
```



### 四、优化器

**优化器是在表里面有多个索引时，`决定使用哪个索引`**

或

**在一个语句有多表关联（join）时，决定各个表的`连接顺序`**



比如执行关联查询语句

```mysql
select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

* 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20
* 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案



### 五、执行器

开始执行SQL语句

1. 先判断对该表是否有`查询权限`
2. 如果有权限则`打开表`继续执行

>打开表时，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。



比如

```mysql
select * from T where ID=10;
```

假设表T中ID 字段`没有索引`，`执行器的执行流程`为：

1. 调用 `InnoDB 引擎相关接口`查表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存到结果集中

2. 继续取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行

3. 执行器将上述`遍历`过程中`所有满足条件的行`组成的记录集作为结果集返回给客户端




数据库的`慢查询日志`有一个 `rows_examined` 的字段，表示这个语句执行过程中`扫描了多少行`。

这个值就是在执行器`每次调用引擎获取数据行`时累加的。

> 在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的



# 二、更新语句是怎么执行的

## 基本流程

更新语句也和查询语句基本一样

1. 连接器连接

2. 把该表的所有查询缓存结果清空

3. 分析器分析

4. 优化器

5. 执行器找到要更新的数据，执行更新




## 两种日志

更新流程涉及到两个重要的`日志模块`

* redo log(重做日志)

* binlog(归档日志)




### 一、redo log和bingo区别

1. `redo log` 是` InnoDB 引擎`特有的

2. `binlog `是 MySQL 的`Server 层`实现的，所有引擎都可以使用

   

3. `redo log` 是`物理日志`，记录的是`“在某个数据页上做了什么修改”`

4. `binlog` 是`逻辑日志`，记录的是这个语句的原始逻辑，比如`“给 ID=2 这一行的 c 字段加 1”`

   

5. `redo log` 是`循环写的`，是`固定大小`的，所以空间会用完

6. `binlog` 是可以`追加写入的`

   > “追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志



7. binlog用于`数据库备份`，假设`备库`当前存的是`主库T1时间的数据`，那么要把`当前时间T-T1`之间的数据备份，则`取binlog从T1时间开始到T时间`的操作应用于备库即可

8. redo log用于`crash-safe保证`，假设主库突然crash停机了，重新开机后，`通过检测redo log状态与binlog记录`来决定是`回滚`还是`执行`以便保证数据完整性、以及确保binlog记录的事务与最终的数据一致（这样binlog用于数据库备份就是完整的）



### 二、redo log重做日志(InnoDB特有)

redo log 是 InnoDB 引擎`特有`的日志



**类比**

如果饭店老板把赊账的人记在`黑板`，redo log即黑板上记的名字



**要解决的问题**

MySQL更新数据时，如果每一次的更新操作都需要`写进磁盘`，然后磁盘也要`找到对应的那条记录`，然后再`更新`，整个过程 `IO成本`(随机IO)、`查找成本`都很高



**解决方法**

为了解决这个问题，MySQL 用了`先记录下更新的操作日志，事后再去写磁盘`的思路来提升更新效率，其实就是 `WAL 技术`



#### **WAL技术**

WAL 的全称是 `Write-Ahead Logging`，它的关键点就是`先写日志，再写磁盘`



**InnoDB引擎一条记录的更新流程**

1. 先查询页数据到buffer_pool

2. 更新buffer_pool的页数据

3. InnoDB引擎先记录redo log(顺序IO)

   > redo log也在磁盘，是一个固定的区域，是`顺序IO`

4. 更新内存

5. 此时更新就完成了

6. 后续系统比较空闲时，InnoDB会把redo log的记录刷到磁盘中



**redo log写满了怎么办**

InnoDB 的 redo log 是`固定大小`的，比如可以配置为`一组 4 个文件`，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。

`当写满了，则会擦除掉一些记录，擦除记录之前会把记录更新到数据文件，即更新到磁盘`



 **crash-safe能力**

有了 `redo log`，`InnoDB` 就可以保证即使数据库发生`异常重启`，`之前提交的记录都不会丢失`，这个能力称为 `crash-safe`，MyISAM 没有 crash-safe 的能力




### 三、binlog归档日志

binlog 是 MySQL 的 Server 层实现的，`所有引擎都可以使用`



**binlog有两种模式**

* statement 格式：记录sql语句
* row格式：记录行的内容，`记两条`，更新前和更新后都有



### 四、执行update语句时的内部流程

比如执行语句：将 ID=2 这一行的值加 1, ID是主键

```mysql
update T set c=c+1 where ID=2;
```

1. 执行器先找引擎`取 ID=2 这一行`

   > ID 是主键，引擎直接`用树搜索`找到这一行。如果 ID=2 这一行所在的`数据页`本来就在`内存`中，就直接返回给`执行器`；否则，需要`先从磁盘读入内存`，然后再返回

2. 执行器拿到引擎给的`行数据`，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口`写入这行新数据`

3. 引擎将这行新数据`更新到内存中`，同时将这个`更新操作记录到 redo log` 里面，此时 redo log 处于` prepare 状态`。然后告知执行器执行完成了，`随时可以提交事务`

4. `执行器`生成这个操作的 `binlog`，并`把 binlog 写入磁盘`

5. 执行器调用引擎的`提交事务`接口，引擎把刚刚写入的 redo log 改成`提交（commit）状态`，更新完成



**这个过程涉及到了两阶段提交**

最后三步中，将 `redo log 的写入`拆成了两个步骤：prepare 和 commit



如图，图中`浅色框`表示是在 `InnoDB 内部`执行的，`深色框`表示是在`执行器`中执行的

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/MySQLStudy/update%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png)



### 五、两阶段提交

两阶段提交是为了`让两份日志之间的逻辑一致`



**怎样让数据库恢复到半个月内任意一秒的状态？**

当需要恢复到指定的某一秒时，比如`某天下午两点`发现中午十二点有一次误删表，需要`找回数据`，那你可以这么做

1. 首先，找到最近的一次`全量备份`，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到`临时库`
2. 然后，`从最近一次备份的时间点开始`，`将备份的 binlog 依次取出来`，重放到中午误删表之前的那个时刻

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去



**为什么日志需要“两阶段提交”**

由于 redo log 和 binlog 是`两个独立的逻辑`，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序，那么`数据库的状态`就有可能和`用它的日志恢复出来的库的状态`不一致



用前面的 update 语句来做例子，假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

1. 先写 redo log 后写 binlog（可能影响备份日志的binlog）

>假设在 redo log `写完`，binlog 还`没有写完`时，`MySQL 进程异常重启`。
>
>由于前面说过，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时 binlog 里面就没有记录这个语句
>
>因此，之后`备份日志`的时候，存起来的 binlog 里面就没有这条语句。`如果需要用这个 binlog 来恢复临时库的话`，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同

2. 先写 binlog 后写 redo log

>如果在 binlog 写完之后 crash，`由于 redo log 还没commit即没写，崩溃恢复以后这个事务无效`，所以这一行 c 的值是 0。但是 binlog 里面已经记录了`“把 c 从 0 改成 1”这个日志`。所以，在之后用 binlog 来恢复时就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同



**平时恢复临时库的场景**

比如当需要`扩容`时，也就是需要再`多搭建一些备库来增加系统的读能力`时，

常见的做法是`用全量备份`加上`应用 binlog 来`实现的，如果redo log和binlog“不一致”就会导致你的线上出现`主从数据库不一致`的情况



## 三、小结

1. redo log 用于保证 crash-safe 能力

   `innodb_flush_log_at_trx_commit 这个参数设置成 1 时，表示`每次事务的 redo log 都直接持久化到磁盘`。这个参数我建议你设置成 1，这样可以`保证 MySQL 异常重启之后数据不丢失

2. `sync_binlog` 这个参数设置成 1 时，`表示每次事务的 binlog 都持久化到磁盘`。这个参数我也建议你设置成 1，这样保证 MySQL 异常重启之后 binlog 不丢失

