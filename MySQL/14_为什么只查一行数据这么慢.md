# 表结构

```sql
// 建表语句
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

// 插入 10 万行记录
delimiter ;;
create procedure idata()
begin
  declare i int;
  set i=1;
  while(i<=100000) do
    insert into t values(i,i);
    set i=i+1;
  end while;
end;;
delimiter ;

call idata();
```



# 查询时间长的场景

执行SQL，如果出现查询结果长时间不返回，大概率是`表t被锁住`了

```sql
select * from t where id=1;
```



## 分析原因

1. 首先执行一下 `show processlist `命令，看看当前语句处于什么状态
2. 接着再针对每种状态，去分析它们产生的原因，如何复现，以及如何处理



## 分析3种被堵住的情况

### 等MDL锁

**Waiting for table metadata lock 状态**

执行`show processlist`，输出的State字段值为` Waiting for table metadata lock` ，表示现在有一个线程正在表 t 上请求 或者 持有 MDL 写锁，把 select 语句堵住了

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709211447.png)



**复现步骤**

>  前提：MySQL 5.7 版本

1. session A 通过 lock table 命令`持有表 t 的 MDL 写锁`

2. session B 的查询`需要获取 MDL 读锁`，所以session B 进入等待状态

| Session A           | Session B                     |
| ------------------- | ----------------------------- |
| lock table t write; |                               |
|                     | select * from t where id = 1; |



此时show processlist如下

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql20220523214513.png)

id为11的这行提示`select * from t where id = 1`被阻塞了，



**如何处理**

找到谁持有MDL写锁，然后把它 kill 掉。



因为show processlist看不出是哪个进程持有MDL锁，需要查询sys系统库的 `sys.schema_table_lock_waits`表 ，查出造成阻塞的进程id，把这个连接kill掉接口，如 `kill 进程id`

> MySQL启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失

```sql
select blocking_pid from sys.schema_table_lock_waits;
-- 此时阻塞id正好是上图中id为10的记录
kill 10
```



### 等待flush刷脏

**Waiting for table flush状态**

执行`show processlist`，输出的State字段值为` Waiting for table flush` ，这个状态表示现在有一个线程`正要对表 t 做 flush 操作`



**对表做 flush 的2个用法**

> 正常这两个语句执行起来都很快，除非它们也被别的线程堵住了
>

```sql
flush tables t with read lock;  -- 表示只关闭表 t
```

```sql
flush tables with read lock; -- 没有指定具体的表名，则表示关闭 MySQL 里所有打开的表
```

所以出现 Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了select 语句



**复现步骤**

1. 在 session A 中，调用一次 sleep(1)，这样这个语句默认要执行 10 万秒，在这期间表 t 一直是被 session A“打开”着
2. session B 的 flush tables t 命令再要去关闭表 t，就需要等 session A 的查询结束
3. session C 要再次查询的话，就会被 flush 命令堵住了

| Session A               | Session B       | Session C                     |
| ----------------------- | --------------- | ----------------------------- |
| select sleep(1) from t; |                 |                               |
|                         | flush tables t; |                               |
|                         |                 | select * from t where id = 1; |

**show processlist 结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql20220523215131.png)

如上图，可执行`Kill 13`杀死sleep语句



### 等行锁

```sql
select * from t where id=1 lock in share mode; 
```

由于访问 id=1 这个记录时要`加读锁`，如果这时已经有一个事务在这行记录上持有一个写锁， 上面的select 语句就会被堵住。



**复现步骤**

1. session A 启动了事务，占有写锁，还不提交

   >  查看是否开启自动提交： SHOW VARIABLES LIKE 'autocommit';
   >
   > 关闭自动提交： SET autocommit = 0; 

2. session B查询同一行记录，导致 session B 被堵住

| Session A                        | Session B                                        |
| -------------------------------- | ------------------------------------------------ |
| begin;                           |                                                  |
| update t set c=c+1 where id = 1; |                                                  |
|                                  | select * from t where id = 1 lock in share mode; |



**show processlist结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709213640.png)



**查出是谁占着这个写锁**

如果是 MySQL 5.7 版本，可以通过` sys.innodb_lock_waits 表`查到

```sql
select * from  sys.innodb_lock_waits where locked_table='`库名`.`表名`'\G
```

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql20220523220954.png)

从输出结果可看出，是18号线程造成堵塞的。



* 可用 kill 18干掉它，kill 18也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开时，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。

* 而kill query 18：表示停止 `18号线程当前正在执行的语句`，而这个方法其实是没有用的。因为占有行锁的是 update 语句，这个语句已经是之前执行完成了的，现在执行 kill query，无法让这个事务去掉 id=1 上的行锁。



# 查询慢的场景(一致性读导致慢查询)

 **执行SQL1**

```sql
select * from t where c=50000 limit 1;
```

由于字段c没有索引，这个语句只能走` id主键顺序扫描`，因此需要扫描 5 万行。

> 可以将慢查询日志的时间阈值设置为 0，然后看一下慢查询日志验证扫描行数，慢日志的Rows_examined 显示扫描了 50000 行。



 **执行SQL2**

```sql
-- 通过查询慢日志，发现扫描行数是 1，但执行时间却长达 800 毫秒
select * from t where id=1;

-- 执行时扫描行数也是1行，但执行时间是0.2毫秒。按理说 lock in share mode 还要加锁，时间应该更长才对啊
select * from t where id=1 lock in share mode;
```



两个语句的输出结果

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709215841.png)

第一个语句的查询结果里 c=1，带 lock in share mode 的语句返回的是 c=1000001。



**复现步骤**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709215924.png)

session A 先用 `start transaction with consistent snapshot` 命令启动了一个事务，之后 session B 才开始执行 update 语句。



**session B 执行完 100 万次 update 语句后，id=1 这一行处于什么状态呢？**

> 注意，undo log 里记录的其实是“把 2 改成 1”，“把 3 改成 2”这样的操作逻辑，画成减 1 的目的是方便看图。

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/19_id=1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81)

session B 更新完 100 万次，生成了 100 万个回滚日志 (undo log)



1. 带 lock in share mode 的 SQL 语句，是`当前读`，因此会直接读到 1000001 这个结果，所以速度很快

2. 而 select * from t where id=1 这个语句，是`一致性读`，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回


