# 表结构

```sql
// 建表语句
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

// 插入 10 万行记录
delimiter ;;
create procedure idata()
begin
  declare i int;
  set i=1;
  while(i<=100000) do
    insert into t values(i,i);
    set i=i+1;
  end while;
end;;
delimiter ;

call idata();
```



# 查询时间长场景

执行SQL

```sql
select * from t where id=1;
```

如果出现查询结果长时间不返回，大概率是`表 t 被锁住`了



## 分析原因

1. 首先执行一下 `show processlist `命令，看看当前语句处于什么状态
2. 我们再针对每种状态，去分析它们产生的原因、如何复现
3. 以及如何处理



## 分析3种被堵住的情况

### 等 MDL 锁

**` Waiting for table metadata lock` 状态**

执行`show processlist`命令，显示` Waiting for table metadata lock` 状态

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709211447.png)

这个状态表示现在有一个线程正`在表 t 上请求 或者 持有 MDL 写锁`，把 select 语句`堵住`了



**在` MySQL 5.7 版本`下的复现步骤如下**

1. session A 通过 lock table 命令`持有表 t 的 MDL 写锁`

2. session B 的查询`需要获取 MDL 读锁`，所以session B 进入等待状态

| Session A           | Session B                     |
| ------------------- | ----------------------------- |
| lock table t write; |                               |
|                     | select * from t where id = 1; |



**处理方式**

找到谁持有 MDL 写锁，然后把它 kill 掉



**怎么找到MDL写锁**

通过查询sys系统库的表 `sys.schema_table_lock_waits` 这张表，就可以`直接找出造成阻塞的 process id`，把这个连接用 `kill 命令`断开即可

```sql
select blocking_pid from sys.schema_table_lock_waits;
```

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709212012.png)

> MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失



### 等待flush

执行SQL

```sql
select * from information_schema.processlist where id=1;
```

**`Waiting for table flush`状态**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709213100.png)

这个状态表示现在有一个线程`正要对表 t 做 flush 操作`



###  **对表做 flush 的2个用法**

```bash
flush tables t with read lock; // 代表的是只关闭表 t
```

```bash
flush tables with read lock; // 没有指定具体的表名，则表示关闭 MySQL 里所有打开的表
```

正常这两个语句执行起来都很快，除非它们也被别的线程堵住了



所以出现 Waiting for table flush 状态的可能情况是：

`有一个 flush tables 命令被别的语句堵住了`，然后它又堵住了我们的 select 语句



**复现步骤如下**

1. 在 session A 中，调用一次 sleep(1)，这样这个语句默认要执行 10 万秒，在这期间表 t 一直是被 session A“打开”着
2. session B 的 flush tables t 命令再要去关闭表 t，就需要等 session A 的查询结束
3. session C 要再次查询的话，就会被 flush 命令堵住了

| Session A               | Session B       | Session C                     |
| ----------------------- | --------------- | ----------------------------- |
| select sleep(1) from t; |                 |                               |
|                         | flush tables t; |                               |
|                         |                 | select * from t where id = 1; |

**show processlist 结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210709213416199.png)



### 等行锁

执行SQL

```sql
select * from t where id=1 lock in share mode; 
```



由于访问 id=1 这个记录时要`加读锁`，如果这时已经有一个事务在这行记录上持有一个写锁， select 语句就会被堵住



**复现步骤如下**

1. session A 启动了事务，占有写锁，还不提交
2. Session B查询同一行记录，导致 session B 被堵住

| Session A                        | Session B                                        |
| -------------------------------- | ------------------------------------------------ |
| begin;                           |                                                  |
| update t set c=c+1 where id = 1; |                                                  |
|                                  | select * from t where id = 1 lock in share mode; |



**show processlist结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709213640.png)



**怎么查出是谁占着这个写锁**

如果是 MySQL 5.7 版本，可以通过` sys.innodb_lock_waits 表`查到

```sql
select * from t sys.innodb_lock_waits where locked_table='`test`.`t`'\G
```



![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/19_%E8%A1%8C%E9%94%81showprocesslist)

从输出结果可看出，是4 号线程造成堵塞的，可用 KILL QUERY 4 或 KILL 4干掉它。



不过，这里不应该显示“KILL QUERY 4”

> 这个命令表示停止 4 号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是 update 语句，这个语句已经是之前执行完成了的，现在执行 KILL QUERY，无法让这个事务去掉 id=1 上的行锁。

实际上，`KILL 4 `才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。



# 查询慢场景(当前读和一致性读)

 **执行SQL1**

```sql
select * from t where c=50000 limit 1;
```

由于字段 c 上没有索引，这个语句只能走` id 主键顺序扫描`，因此需要扫描 5 万行。



可以看一下慢查询日志验证扫描行数

> 注意，为了把所有语句记录到 slow log 里，在连接后可以先执行了 set long_query_time=0，将慢查询日志的时间阈值设置为 0

慢日志的Rows_examined 显示扫描了 50000 行。



 **执行SQL2**

```sql
select * from t where id=1；
```

通过查询慢日志，发现`扫描行数是 1，但执行时间却长达 800 毫秒`



慢日志里可以看到另一个语句，`select * from t where id=1 lock in share mode`，执行时扫描行数也是 1 行，执行时间是 0.2 毫秒。按理说 lock in share mode 还要加锁，时间应该更长才对啊



**两个语句的输出结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709215841.png)

第一个语句的查询结果里 c=1，带 lock in share mode 的语句返回的是 c=1000001。



**复现步骤**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210709215924.png)

session A 先用 `start transaction with consistent snapshot` 命令启动了一个事务，之后 session B 才开始执行 update 语句



**session B 执行完 100 万次 update 语句后，id=1 这一行处于什么状态呢？**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/19_id=1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81)

session B 更新完 100 万次，生成了 100 万个回滚日志 (undo log)



1. 带 lock in share mode 的 SQL 语句，是`当前读`，因此会直接读到 1000001 这个结果，所以速度很快

2. 而 select * from t where id=1 这个语句，是`一致性读`，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回



注意，undo log 里记录的其实是“把 2 改成 1”，“把 3 改成 2”这样的操作逻辑，画成减 1 的目的是方便你看图。

