# 临时表和内存表

## 内存表

指 使用Memory引擎 的表，数据都保存在内存里，系统重启的时候会被清空，但是表结构还在

> 建表语法是 `create table … engine=memory`

## 临时表

可以使用各种引擎类型 

> 如果是使用 InnoDB 引擎 或 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。
>
> 当然，临时表也可以使用 Memory 引擎



# 临时表的特点

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713214146.png)

**临时表在使用上有以下5个特点**

1. 建表语法是 `create temporary table …`

2. 一个临时表只能被`创建它的session访问`，对其他线程不可见，在这个 session 结束时，会自动删除临时表

   > 所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的

3. 临时表可以与普通表同名

4. session A 内有同名的临时表和普通表时，show create 语句，以及增删改查语句访问的是`临时表`

5. show tables 命令`不显示临时表`



## join优化时使用临时表

比如在优化 join 查询时使用到了临时表，因为临时表特别适合 join 优化这种场景

```sql
create temporary table temp_t like t1;

alter table temp_t add index(b);

insert into temp_t select * from t2 where b>=1 and b<=2000;

select * from t1 join temp_t on (t1.b=temp_t.b);
```



**原因主要有两个方面：**

1. 不同 session 的临时表是可以`重名`的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题

2. 不需要担心数据删除问题

   > 如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作



# 临时表的应用

由于不用担心线程之间的重名冲突，临时表经常会被`用在复杂查询的优化过程中`。

> 分库分表系统的跨库查询就是一个典型的使用场景



## 分表查询场景

比如。将一个大表 ht，按照`字段 f`，拆分成 `1024 个分表`，然后分布到 32 个数据库实例上。如下图所示：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713214859.png)

一般情况下，分库分表系统都有一个中间层 proxy。在这个架构中，`分区 key `的选择是以`“减少跨库和跨表查询”为依据的`。如果大部分的语句都会包含 f 的等值条件，那么就要用 f 做分区键。



### 能根据分区键查询

在 proxy 这一层解析完 SQL 语句以后，就能确定将这条语句路由到哪个分表做查询。

比如语句：

```sql
select v from ht where f=N;
```

这时可以通过分表规则（比如，`N%1024`) 来确认需要的数据被放在了`哪个分表`上



### 不能根据分区键查询

如果这个表上还有`另外一个索引k`，查询语句是：

```sql
select v from ht where k >= M order by t_modified desc limit 100;
```

这时由于`查询条件里面没有用到分区字段 f`，只能`到所有的分区中去查找满足条件的所有行，然后统一做 order by 的操作`。

这时有两种比较常用的思路。



**第一种思路，在 proxy 层的进程代码中实现排序**

优点：

1. 处理速度快，拿到分库的数据以后，直接在`内存中参与计算`

缺点：

1. 需要的开发工作量比较大，对中间层的开发能力要求比较高
2. 对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题



**另一种思路是，把各个分库拿到的数据，汇总到一个 MySQL 实例的一个临时表中，然后在这个汇总实例上做逻辑操作**

比如上面这条语句，执行流程可以类似这样：

* 在汇总库上创建一个`临时表temp_ht`，表里包含三个字段 v、k、t_modified；
* 在各个分库上执行

```sql
select v,k,t_modified from ht_x where k >= M order by t_modified desc limit 100;
```

* 把分库执行的结果插入到 temp_ht 表中；
* 执行

```sql
select v from temp_ht order by t_modified desc limit 100; 
```

* 得到结果



这个过程对应的流程图如下所示：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713215237.png)



# 为什么临时表可以重名

## frm文件

在执行下面语句时，MySQL要给这个 InnoDB 表创建一个 `frm文件`保存`表结构定义`，还要有地方保存表数据

```sql
create temporary table temp_t(id int primary key)engine=innodb;
```

**这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}_{线程 id}_ 序列号”。**

> 可以使用` select @@tmpdir` 命令，来显示实例的`临时文件目录`。



## 临时表数据存放方式

> 在不同的 MySQL 版本中有着不同的处理方式

* 在 5.6 以及之前的版本，MySQL 会在`临时文件目录`下创建一个`相同前缀、以.ibd 为后缀`的文件，用来存放数据文件
* 而从 5.7 版本开始，MySQL 引入了一个`临时文件表空间`，专门用来存放临时文件的数据。因此，不需要再创建 ibd 文件了



从文件名的前缀规则，其实创建一个叫作` t1 的 InnoDB 临时表`，MySQL 在存储上认为我们创建的表名跟普通表 t1 是不同的，因此同一个库下面已经有普通表 t1 的情况下，还是可以再创建一个临时表 t1 的。



**例子**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713220418.png)

这个进程的进程号是 1234，session A 的线程 id 是 4，session B 的线程 id 是 5。所以session A 和 session B 创建的临时表，在磁盘上的文件不会重名。



MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 `table_def_key`。

* 一个普通表的 table_def_key 的值是由`“库名 + 表名”`得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了
* 而对于临时表，`table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”`



也就是session A 和 sessionB 创建的两个临时表 t1，它们的 table_def_key 不同，磁盘文件名也不同，因此可以并存。



## 临时表链表

在实现上，每个线程都维护了自己的`临时表链表`。

这样每次 session 内操作表时，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在 session 结束时，对链表里的每个临时表，执行 `“DROP TEMPORARY TABLE + 表名”操作`。

> 这时会发现binlog 中也记录了` DROP TEMPORARY TABLE 这条命令`。临时表只在线程内自己可以访问，为什么需要写到 binlog 里面？
>
> 因为这里涉及到了主备复制。



# 临时表和主备复制

如果有主备复制，那临时表的操作记录也要记录到binlog，只在 binlog的格式为statment/mixed 时，binlog 中才会记录临时表的操作。



在主库上执行下面这个语句序列：

```sql
create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/
create temporary table temp_t like t_normal;/*Q2*/
insert into temp_t values(1,1);/*Q3*/
insert into t_normal select * from temp_t;/*Q4*/
```

如果关于临时表的操作都不记录，那么在备库就只有` create table t_normal 表`和` insert into t_normal select * from temp_t `这两个语句的 binlog 日志，备库在执行到 insert into t_normal 时，就会报错`“表 temp_t 不存在”`。



**为什么binlog的格式不能为row**

因为 binlog是row 格式时，在记录` insert into t_normal `的 binlog 时，记录的是这个操作的数据，即：write_row event 里面记录的逻辑是“插入一行数据（1,1)”，那么跟临时表有关的语句，就不会被记录到binlog里了。



**只在binlog的格式为statment/mixed时，binlog 中才会记录临时表的操作**

这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行。



**问题**

MySQL 在记录 binlog 时，不论是 create table 还是 alter table 语句，都是原样记录，甚至于连空格都不变。但是如果执行 drop table t_normal，系统记录 binlog 就会写成：

```sql
DROP TABLE `t_normal` /* generated by server */
```

也就是改成了标准的格式。为什么要这么做呢 ？



原因就是：drop table 命令是可以一次删除多个表的。比如，在上面的例子中，设置 binlog_format=row，如果主库上执行 "drop table t_normal, temp_t"这个命令，那么 binlog 中就只能记录：

```sql
DROP TABLE `t_normal` /* generated by server */
```

因为备库上并没有表 temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。



所以，drop table 命令记录 binlog 时，就必须对语句做改写。“/* generated by server */”说明了这是一个被服务端改写过的命令。



**说到主备复制，还有另外一个问题需要解决：**

主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？



举个例子，下面的序列中实例 S 是 M 的备库：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713221256.png)

主库 M 上的两个 session 创建了同名的临时表 t1，这两个 create temporary table t1 语句都会被传到备库 S 上。



但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个 create 语句两次。（即使开了多线程复制，也可能被分配到从库的同一个 worker 中执行）。那么，这会不会导致同步线程报错 ？



显然是不会的，否则临时表就是一个 bug 了。也就是说，备库线程在执行的时候，要把这两个 t1 表当做两个不同的临时表来处理。这，又是怎么实现的呢？



MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key：

1. session A 的临时表 t1，在备库的 table_def_key 就是：库名 +t1+“M 的 serverid”+“session A 的 thread_id”;
2. session B 的临时表 t1，在备库的 table_def_key 就是 ：库名 +t1+“M 的 serverid”+“session B 的 thread_id”。



由于 table_def_key 不同，所以这两个表在备库的应用线程里面是不会冲突的。



# 什么时候会使用内部临时表

## 建表语句

```sql
create table t1(id int primary key, a int, b int, index(a));

delimiter ;;
create procedure idata()
begin
  declare i int;

  set i=1;
  while(i<=1000)do
    insert into t1 values(i, i, i);
    set i=i+1;
  end while;
end;;
delimiter ;
call idata();
```



## 例1：union

执行下面语句，用到了 union，语义是取这两个子查询结果的并集(就是这两个集合加起来，重复的行只保留一行)

```sql
(select 1000 as f) union (select id from t1 order by id desc limit 2);
```



**explain 结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713223410.png)

* 第二行的 `key=PRIMARY`，说明第二个子句用到了`索引id`
* 第三行的` Extra字段`，表示在对子查询的结果集做 union 时，使用了`临时表 (Using temporary)`



### 执行流程

1. 创建一个`内存临时表`，这个临时表只有一个`整型字段 f`，并且 f 是`主键`字段
2. 执行第一个`子查询`，得到 1000 这个值，并存入临时表中
3. 执行第二个子查询：
   * 拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行
   * 取到第二行 id=999，插入临时表成功
4. 从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999

这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了`临时表主键 id 的唯一性约束`，实现了 union 的语义。



**执行流程图：**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713223524.png)



如果把上面这个语句中的 union 改成 `union all `，就没有了“去重”的语义。



这样执行时就`依次执行子查询`，得到的结果直接作为结果集的一部分，发给客户端。因此也就`不需要临时表`了。

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713223741.png)

第二行的 Extra 字段显示的是 `Using index`，表示只使用了`覆盖索引`，没有用临时表了



## 例2：group by

一个常见的使用临时表的例子是 group by

```sql
select id%10 as m, count(*) as c from t1 group by m;
```

这个语句是把表 t1 里的数据，按照` id%10 `进行分组统计，并按照 m 的结果排序后输出



**explain 结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713224545.png)

* Using index，表示这个语句使用了`覆盖索引`，选择了索引 a，不需要回表
* Using temporary，表示使用了临时表
* Using filesort，表示需要排序



### **执行流程**

1. 创建`内存临时表`，表里有两个字段 m 和 c，主键是m
2. 扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算` id%10 的结果`，记为 x
   * 如果临时表中没有主键为 x 的行，就插入一个记录 (x,1)
   * 如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1
3. 遍历完成后，再根据字段m对临时表做排序，得到结果集返回给客户端



**执行流程图**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713224743.png)



`图6 内存临时表排序流程`，`临时表的排序过程`就是虚线框内的过程

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713224905.png)



**结果需要排序的执行结果**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713225136.png)



**结果不需要排序的执行结果**

如果需求并不需要对结果进行排序，那可以在 SQL 语句末尾增加` order by null`，这样就`跳过了最后排序的阶段`，直接从`临时表`中取数据返回

```sql
select id%10 as m, count(*) as c from t1 group by m order by null;
```



`图 8 group + order by null 的结果（内存临时表）`

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713225228.png)

由于表 t1 中的 id 值是从 1 开始的，因此返回的结果集中第一行是 id=1；扫描到 id=10 的时候才插入 m=0 这一行，因此结果集里最后一行才是 m=0。



这个例子里由于临`时表只有10行`，内存可以放得下，因此全程只使用了内存临时表。



### 内存临时表的大小

**内存临时表的大小是有限制的，由` tmp_table_size `参数控制这个内存大小，默认是 16M。**



**如果内存临时表不够，会把内存临时表转成磁盘临时表。**



例如：

把内存临时表的大小限制为最大 1024 字节，并把语句改成 `id % 100`，这样返回结果里有 100 行数据。

但是，这时的内存临时表大小`不够存下这 100 行数据`，也就是说，执行过程中会发现内存临时表大小到达了上限（1024 字节）。那么，这时就会把内存临时表转成`磁盘临时表`，磁盘临时表默认使用的`引擎是InnoDB`。 

```sql
set tmp_table_size=1024;
select id%100 as m, count(*) as c from t1 group by m order by null limit 10;
```

如果这个表 t1 的数据量很大，很可能这个查询需要的磁盘临时表就会`占用大量的磁盘空间`。



### group by优化方法

#### 方法1 索引

不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个`带唯一索引的表`，执行代价都是比较高的。如果表的数据量比较大，group by 语句执行起来就会很慢。



要解决 group by 语句的优化问题，可以先想一下这个问题：`执行 group by 语句为什么需要临时表`？



group by 的语义逻辑，是`统计不同的值出现的个数`。但是，由于`每一行的 id%100 的结果是无序的`，所以我们就需要有一个临时表，来记录并统计结果。



那么，如果扫描过程中可以`保证出现的数据是有序的`，是不是就简单了呢？



假设现在有一个类似下图这么一个数据结构，来看看 group by 可以怎么做。

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713225926.png)

`图 10 group by 算法优化 - 有序输入`



可以看到，如果可以确保输入的数据是有序的，那么计算 group by 时，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程：

* 当碰到第一个 1 时，已经知道累积了` X 个 0`，结果集里的第一行就是 (0,X)
* 当碰到第一个 2 时，已经知道累积了` Y 个 1`，结果集里的第二行就是 (1,Y)

按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到 group by 的结果，`不需要临时表，也不需要再额外排序`。



你一定想到了，InnoDB 的索引，就可以满足这个输入有序的条件。

在 MySQL 5.7 版本支持了 `generated column` 机制，用来实现列数据的关联更新。



可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。

```sql
alter table t1 add column z int generated always as(id % 100), add index(z);
```

这样，索引 z 上的数据就是类似图 10 这样有序的了。上面的 group by 语句就可以改成：

```sql
select z, count(*) as c from t1 group by z;
```



优化后的 group by 语句的 explain 结果，如下图所示：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713230041.png)

从 Extra 字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。



#### 方法2 直接排序

 如果碰上不适合创建索引的场景。那么这时的 group by 要怎么优化呢？



一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”。



那么，MySQL 有没有让我们`直接走磁盘临时表`的方法呢？

> 答：有的。



在 group by 语句中加入` SQL_BIG_RESULT 这个提示（hint）`，就可以告诉优化器：这个语句涉及的数据量很大，请`直接用磁盘临时表`。



MySQL 的优化器一看，`磁盘临时表`是 `B+ 树存储`，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是`直接用数组来存`吧。



因此，下面这个语句的执行流程就是这样的：

```sql
select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;
```

1. 初始化 `sort_buffer`，确定放入一个整型字段，记为 m
2. 扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中
3. 扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）
4. 排序完成后，就得到了一个有序数组。



根据`有序数组`，得到数组里面的不同值，以及每个值的出现次数。



下面两张图分别是执行流程图和执行 explain 命令得到的结果。

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713230216.png)

图 12 使用 SQL_BIG_RESULT 的执行流程图



![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210713230303.png)

图 13 使用 SQL_BIG_RESULT 的 explain 结果



从 Extra 字段可以看到，这个语句的执行没有再使用临时表，而是直接用了`排序算法`。



## 小结

**MySQL 什么时候会使用内部临时表？**

1. 如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果

2. join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构

3. 如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数


