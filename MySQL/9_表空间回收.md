## 背景

数据库占用空间太大，把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？

答：是数据页空洞造成的，`alter table重建表`可解决



## 一个 InnoDB 表包含两部分

1. 表结构定义

   > 占用空间小

2. 表数据



### 表结构存放位置

* 在 MySQL 8.0 以前，以`.frm `为后缀的文件

* 而 MySQL 8.0 ，允许把`表结构`放在`系统数据表`中



### 表数据存放位置

**innodb_file_per_table 参数**：控制表数据的存放位置

1. 设置为 OFF ：表数据放在`系统共享表空间`，即跟`数据字典`放在一起
2. 设置为 ON ：表示每个 InnoDB 表的数据存储在一个以 `.ibd 为后缀`的单独文件中

> 从 MySQL 5.6.6 版本开始，默认值是 ON 



**建议**

1. 永远将这个值设置为 ON

> 因为一个表数据单独存储为一个文件更容易管理，在不需要这个表时，通过` drop table` 命令，系统就会直接删除这个文件。而如果是`放在共享表空间中，即使表删掉了，空间也是不会回收的`。

2. 在删除整个表时，可以用 `drop table 命令回收表空间`

> 当删除某些行时，表中的数据被删除了，但是表空间却没有被回收，这是因为页空洞造成的



## 数据删除delete流程

InnoDB 中一个索引的示意图 (B+树) 图1

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/13_b+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%9B%BE.jpeg)

### 记录复用(标记删除)

1. 删除单条记录（记录复用）

   > 要删掉 R4 这条记录，InnoDB引擎只会把 R4 这个记录`标记为删除`，磁盘文件的大小并不会缩小。
   >
   > 如果之后要再插入一个ID在300和600之间的记录时，可能会`复用这个位置`

2. 删除整个数据页（整个数据页复用）

   > InnoDB 的数据是`按页存储`的，如果删掉了`一个数据页上`的所有记录，整个数据页就可以被复用了



**记录的复用 和 数据页的复用 的区别**

1. 记录的复用，只限于`符合范围条件`的数据

   > 比如R4 这条记录被删除后，如果插入一个 ID 是 400 的行，可以直接复用这个空间。但如果插入的是一个 ID 是 800 的行，就不能复用这个位置

2. 数据页的复用，可以复用到`任何位置`

   > 如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时如果要插入一条 ID=50 的记录需要使用新页时，page A 是可以被复用的



### 数据页合并

如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据`合到其中一个页上`，另外一个数据页就被标记为`可复用`



### 增删改会造成数据页空洞

经过`大量增删改`的表，都是可能是存在空洞的



**delete删除数据**

用 `delete`把整个表的数据删除，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小

> delete 命令其实只是把`记录的位置`，或者`数据页`标记为了`“可复用”`，但磁盘文件的大小是不会变的。
>
> 也就是 `delete 命令是不能回收表空间的`。这些可以复用，而没有被使用的空间，看起来就像是“空洞”



**插入数据可能有页分裂**

`插入数据`也会造成页空洞

> 如果数据是按照索引`递增顺序`插入的，那么索引是`紧凑`的。但如果数据是随机插入的，就可能造成索引的`数据页分裂`



假设下图中 page A 已经满了，这时我要再插入一行数据，会怎样呢？

> 由于 `page A 满`了，再插入一个 ID 是 550 的数据时，就得再`申请一个新的页面 page B 来保存数据了`。页分裂完成后，page A 的末尾就留下了空洞（注意：实际上，可能不止 1 个记录的位置是空洞）



图2

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/13_%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%87%B4%E9%A1%B5%E5%88%86%E8%A3%82.jpeg)



**更新索引上的值**

`更新索引上的值`，可以理解为删除一个旧的值，再插入一个新值。这也是会造成空洞的



#### 重建表

`重建表`能够把这些空洞去掉，达到`收缩表空间`的目的



## 2种重建表的实现

### 思路

如果有一个表 A，需要做`空间收缩`，为了把表中存在的空洞去掉，可以怎么做呢？

1. 可以新建一个与表 A 结构相同的`临时表 B`
2. 然后按照`主键 ID `递增的顺序
3. 把数据一行一行地从表 A 里读出来再插入到表 B 中
4. 数据从表 A 导入表 B 的操作完成后，用表 B 替换 表A



### 用alter来重建表

**可以使用 `alter table A engine=InnoDB 命令`来重建表**



#### 非Online DDL

**MySQL5.5版本之前的实现方式（非Online DDL）**

在 MySQL 5.5 版本之前，这个命令的执行流程跟前面描述的思路差不多，区别只是这个`临时表 B `不需要自己创建，`MySQL 会自动完成转存数据、交换表名、删除旧表的操作`。



最花时间的步骤是`往临时表插入数据`的过程，如果在这个过程中，有新的数据要`写入到表 A `的话，就会`造成数据丢失`。因此，在整个 DDL 过程中，`表 A 中不能有更新`。也就是说，这个 DDL 不是 Online 的



整体流程如下图，图3

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/13_%E6%94%B9%E9%94%81%E8%A1%A8DDL.jpeg)



#### Online DDL

**MySQL 5.6 版本的实现方式(Online DDL)**

而在 MySQL 5.6 版本开始引入的` Online DDL`，对这个操作流程做了优化。



简单描述一下 Online DDL 重建表的流程：

1. 建立一个`临时文件`，扫描`表A 主键`的所有数据页
2. 用数据页中表 A 的记录生成 B+ 树，存储到`临时文件`中
3. 生成临时文件的过程中，将`所有对 A 的操作记录在一个日志文件（row log）中`，对应的是图中 state2 的状态
4. 临时文件生成后，将`日志文件row log中的操作`应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态
5. 用临时文件替换表 A 的数据文件



如下Online DDL图，图4

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/13_%E6%94%B9%E9%94%81%E8%A1%A8DDL.jpeg)



**区别**

MySQL5.5和MySQL5.6的不同之处在于，由于`日志文件记录`和`重放操作`这个功能的存在，这个方案在重建表的过程中，`允许对表 A 做增删改操作`。这也就是 Online DDL 名字的来源。



**问题**

1. DDL 之前是要拿` MDL 写锁`的，这样还能叫 Online DDL 吗？

确实，上图流程中，`alter 语句在启动时`需要`获取 MDL 写锁`，但是这个`写锁在真正拷贝数据之前就退化成读锁了`

2. 为什么要退化呢？

为了实现 Online，MDL 读锁`不会阻塞增删改操作`



而对于一个大表来说，Online DDL 最耗时的过程就是`拷贝数据到临时表`的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，`锁的时间非常短`。对业务来说，就可以认为是 Online 的。



上述的这些重建方法都会`扫描原表数据和构建临时文件`。对于很大的表来说，这个操作是`很消耗 IO 和 CPU 资源的`。

因此，如果是线上服务，要很小心地`控制操作时间`。如果想要比较安全的操作的话，推荐使用 GitHub 开源的` gh-ost` 来做



### Online 和 inplace的区别

inplace是另一个跟 DDL 有关的、容易混淆的概念



1. 在图 3 中（MySQL5.5），把表 A 中的数据导出来的存放位置叫作` tmp_table`，这是一个临时表，是在 server 层创建的

2. 在图 4 中（MySQL5.6），根据表 A 重建出来的数据是放在`tmp_file`里的，这个临时文件是` InnoDB 在内部创建出来`的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源



**问题1**

如果有一个 1TB 的表，现在磁盘间是 1.2TB，能不能做一个 inplace 的 DDL 呢？

答案是不能。因为`tmp_file` 也是要`占用临时空间`的



**copy**

重建表的这个语句`alter table t engine=InnoDB`，其实隐含的意思是：

```sql
alter table t engine=innodb,ALGORITHM=inplace;
```

跟 inplace 对应的就是拷贝表的方式了，用法是：

```sql
alter table t engine=innodb,ALGORITHM=copy;
```

当使用` ALGORITHM=copy` 的时候，表示的是`强制拷贝表`，对应的流程就是图 3 的操作过程（MySQL5.5）。



**问题2**

但我这样说你可能会觉得，inplace 跟 Online 是不是就是一个意思？

>  其实不是的，只是在重建表这个逻辑中刚好是这样而已。

比如，如果我要给 InnoDB 表的一个字段加`全文索引`，写法是：

```sql
alter table t add FULLTEXT(field_name);
```

这个过程是 inplace 的，但`会阻塞增删改操作`，是非 Online 的。



**这两个逻辑之间的关系**

如果说这两个逻辑之间的关系是什么的话，可以概括为：

1. DDL 过程如果是 Online 的，就一定是 inplace 的
2. 反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。



**延伸**

使用 `optimize table`、`analyze table` 和` alter table` 这3种方式重建表的区别

1. 从 MySQL 5.6 版本开始，`alter table t engine = InnoDB（也就是 recreate）`默认的就是上面图 4 的流程了
2. `analyze table t `其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁
3. `optimize table t`等于` recreate + analyze`

