# 规则的前提说明

这个规则只限于截止到现在的最新版本，即 

1. 5.x 系列， <=5.7.24
2. 8.0 系列，<=8.0.13



# 加锁规则

间隙锁在`可重复读`隔离级别下才有效，所以本文所讲的默认是可重复读隔离级别



可重复读隔离级别遵守`两阶段锁协议`，所有加锁的资源，都是在`事务提交或者回滚`时才释放的



## 两个'原则'

1. 原则 1：加锁的基本单位是 `next-key lock`，`next-key lock` 是`前开后闭区间`
2. 原则 2：查找过程中`访问到的对象（如索引）`才会加锁

> 访问到的对象，要从底层的结构来看待，而不是数据表的一行，而是如索引、主键索引之类的底层数据结构。 
>
> 例如普通索引和主键索引，如果访问的是普通索引，而且通过索引覆盖并不需要回表查主键索引，那么主键索引上是没有加任何锁的，因为并没有访问主键索引树上的“对象”



## 两个'优化'

1. 优化 1：`索引`上的等值查询，给`唯一索引`加锁时，`next-key lock 退化为行锁`
2. 优化 2：`索引`上的等值查询，如果不是唯一索引，`向右遍历`时且`最后一个值不满足等值条件`的时候，`next-key lock 退化为间隙锁`



##  一个'bug'

1. 一个 bug：唯一索引上的`范围查询`会访问到`不满足条件的第一个值为止`

> 范围查询：无论是否是唯一索引，范围查询都需要访问到不满足条件的第一个值为止

> mysql 8.0.18 开始，修复了这个 bug



# 建表语句

表 t 的建表语句和初始化语句

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```



# 案例一：等值查询-间隙锁

`等值条件`操作间隙的例子：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210710132627779.png)

session A，表 t 中没有` id=7 `的记录，用加锁规则分析如下：

1. 根据`原则 1`，加锁单位是 next-key lock，session A 加锁范围就是 `(5,10]`
2. 根据`优化 2`，这是一个`等值查询 (id=7)`，而 `id=10 不满足查询条件`，next-key lock 退化成`间隙锁`
3. 因此session A最终加锁的范围是 `(5,10)`



所以，session B 要往`这个间隙里面插入 id=8 的记录会被锁住`，但是 `session C 修改 id=10 这行是可以的`

> 是因为(8,8,8)中的第一个值id=8导致的，不是因为c=8或者d=8导致的。这里是因为`主键索引id上有间隙锁(5,10)`，只要是id=8，此时不管c和d的值是多少，都会被阻塞插入




# 案例二：非唯一索引-等值锁

关于覆盖索引的锁例子：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710133021.png)

session A `lock in share mode`给`索引 c 上 c = 5 的这一行`加上`读锁`

1. 根据`原则 1`，加锁单位是 next-key lock，因此会给` (0,5]`加上 next-key lock
2. 注意 c 是`普通索引`，因此仅访问 c=5 这一条记录不能马上停下来，需要`向右遍历`，`查到 c=10 才停止`。根据`原则 2`，访问到的都要加锁，因此要给` (5,10]`加 next-key lock
3. 根据`优化 2`：等值判断，向右遍历，最后一个值10不满足 c=5 这个等值条件，因此退化成间隙锁` (5,10)`
4. 根据`原则 2` ，只有访问到的对象才会加锁，这个查询使用`覆盖索引`，并`不需要访问主键索引`，所以`主键索引上没有加任何锁`，这就是为什么 session B 的 update 语句可以执行完成



但 session C 要插入一个` (7,7,7)` 的记录，就会被` session A 的间隙锁 (5,10) 锁住`。

> 因为c=7这一行已经被session A锁住了



**注意**

在这个例子中，`lock in share mode 只锁覆盖索引`，但是如果是` for update `就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给`主键索引`上满足条件的行加上行锁。



### 锁是加在索引上的

这个例子说明，`锁是加在索引上的`；



如果要用 lock in share mode 来给`行加读锁避免数据被更新`的话，就必须得`绕过覆盖索引的优化`，在`查询字段中加入索引中不存在的字段`。

比如，将 session A 的查询语句改成` select d from t where c=5 lock in share mode`，此时会回表去查主键索引，访问到的主键索引也会加锁



# 案例三：主键索引-范围锁

**问题**

对于我们这个表 t，下面这两条查询语句，加锁范围相同吗？

```sql
select * from t where id=10 for update;

select * from t where id>=10 and id<11 for update;
```

它们并不完全等价。在逻辑上，这两条查语句肯定是等价的，但是它们的`加锁规则不太一样`。



关于范围查询的例子，让 session A 执行第二个查询语句，来看看加锁效果

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710133818.png)



**用加锁规则分析一下 session A 会加什么锁**

1. 开始执行时，要找到第一个` id=10`的行，此时是` next-key lock(5,10]`。 根据`优化 1`， 主键 id 上的`等值条件`，退化成`行锁`，只加了` id=10 `这一行的行锁
2. `范围查找`就往后继续找，找到 id=15 这一行停下，因此需要加 `next-key lock(10,15]`

3. 所以，session A 这时候锁的范围就是`主键索引上`，`行锁 id=10 和 next-key lock(10,15]`。这样，session B 和 session C 的结果你就能理解了。



**注意**

首次 session A 定位查找 id=10 的行时，是`当做等值查询来判断的`，而向右扫描到 id=15 的时候，用的是`范围查询判断`



# 案例四：非唯一索引-范围锁

与案例三的区别是，案例四中查询语句的 where 部分用的是`字段 c`

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710134320.png)

**session A 用`字段 c `来判断，加锁规则跟案例三唯一的不同是：**

1. 在第一次用 c=10 定位记录时，索引 c 上加了` (5,10]这个 next-key lock `后，由于索引 c 是非唯一索引，`没有优化规则`，也就是说不会变为行锁，因此最终 sesion A 加的锁是，索引 c 上的` (5,10] `和` (10,15] `这两个 next-key lock



所以sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。



这里需要扫描到 c=15 才停止扫描，是合理的，因为 `InnoDB 要扫到 c=15，才知道不需要继续往后找了`



# 案例五：唯一索引-范围锁bug

关于加锁规则中 bug 的例子

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/egg/image-20210710134511986.png)



1. session A 是一个范围查询，按照`原则 1 `的话，应该是`索引 id `上只加` (10,15]`这个 next-key lock，并且因为` id 是唯一键`，所以循环判断到` id=15 这一行就应该停止`了

2. 但是实现上，`InnoDB 会往前扫描到第一个不满足条件的行为止`，也就是` id=20`。而且由于这是个`范围扫描`，因此索引 id 上的` (15,20]`这个 next-key lock 也会被锁上



所以session B 要更新 id=20 这一行，是会被锁住的。

同样地，session C 要插入 id=16 的一行，也会被锁住。



照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为`扫描到 id=15，就可以确定不用往后再找了`。但实现上还是这么做了，因此这是个 bug。



# 案例六：非唯一索引上存在"等值"的例子

为了更好地说明“间隙”这个概念的例子。给表 t 插入一条新记录

```sql
insert into t values(30,10,30);
```



新插入的这一行` c=10`，也就是说现在表里有`两个 c=10 的行`。

那么，这时索引 c 上的间隙是什么状态了呢？你要知道，由于`非唯一索引上包含主键的值`，所以是`不可能存在“相同”的两行的`。



**非唯一索引等值的例子**

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710134803.png)

虽然有两个 c=10，但是它们的`主键值 id 是不同的`（分别是 10 和 30），因此这两个 c=10 的记录之间，也是`有间隙`的。

> 图中画出了索引 c 上的主键 id。为了跟间隙锁的开区间形式进行区别，我用` (c=10,id=30) `这样的形式，来表示索引上的`一行`



这次用 delete 语句来验证。

注意，delete 语句加锁的逻辑，其实跟` select ... for update` 是类似的，也就是在文章开始总结的两个“原则”、两个“优化”和一个“bug”

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710134914.png)

1. session A 在遍历时，先访问第一个 c=10 的记录。同样地，根据`原则 1`，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。

2. 然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据`优化 2`，这是一个`等值查询`，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。



也就是说，这个 delete 语句在`索引 c `上的加锁范围，就是下图中蓝色区域覆盖的部分

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135034.png)





# 案例七：limit 语句加锁

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135101.png)



这个例子里，session A 的 delete 语句加了 limit 2

表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。



这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。



因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135128.png)



(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此 insert 语句插入 c=12 是可以执行成功的。



在删除数据的时候`尽量加 limit`。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围



# 案例八：一个死锁的例子

再看一个案例用来说明：next-key lock 实际上是间隙锁和行锁加起来的结果



![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/20210710135217.png)

**按时间顺序来分析一下为什么是这样的结果**

1. session A 启动事务后执行查询语句加 lock in share mode，在`索引 c `上加了 `next-key lock(5,10] `和`间隙锁 (10,15)`
2. session B 的 update 语句也要在`索引 c `上加 `next-key lock(5,10]` ，进入锁等待
3. 然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了`死锁`，InnoDB 让 session B 回滚



**你可能会问，session B 的 next-key lock 不是还没申请成功吗？**

其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。



也就是说，我们在分析加锁规则时可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成`间隙锁`和`行锁`两段来执行的。

