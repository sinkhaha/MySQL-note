# 索引的作用

为了`提高数据查询的效率`

> MySQL的索引是在`存储引擎层`实现的。



# 索引的常见的数据结构

介绍3种常见的数据结构，分别是`哈希表、有序数组、搜索树`



## 哈希表

**优点：**

根据键`查找方便`，适合`等值查询`



**缺点：**

1. 键值对存储，会有哈希冲突

2. `不适合做范围查询`

   > 数据的存储不是有序的，所以查询某个范围的数据`只能遍历整个哈希表`



## 有序数组

**优点：**

1. 适合等值查询（二分查找O(log(N))）
2. 适合范围查询（先用二分查找找到，然后范围区间的左边值，然后向右遍历取值即可）

**缺点**

1. 不适合插入数据

   > 数组插入数据需要移动该位置后的数据，所以有序数组适用了静态数组存储静态数据（这类数据不会改变）



## 搜索树

树可以有二叉，也可以有多叉

> 多叉树就是每个节点有多个儿子，儿子之间的`大小保证从左到右递增`



#### **二叉搜索树**

**二叉搜索树的特点**

父节点左子树所有结点的值`小于父节点`的值，右子树所有结点的值`大于父节点`的值。

> 为了维持 O(log(N)) 的查询复杂度，就需要保持这棵树是`平衡二叉树`。为了做这个保证，更新的时间复杂度也是 O(log(N))



**优点**

搜索效率最高

**缺点**

二叉树树高过高，每次查询都需要访问过多节点，即访问数据块过多，而从磁盘`随机读取`数据块过于耗时，因为索引不止存在内存中，还要写到磁盘上

> 可以想象一下一棵 100 万节点的平衡二叉树，树高 20。
>
> 一次查询可能需要访问 20 个数据块。在机械硬盘时代，`从磁盘随机读一个数据块需要 10 ms 左右的寻址时间`。
>
> 也就是说，对于一个 100 万行的表，如果使用二叉树来存储，`单独访问一个行`可能需要 20 个 10 ms 的时间，太慢了



#### N叉树

**优点**

查询过程访问的数据块比二叉树少，即读磁盘次数更少



**“N 叉”树中的“N”取决于数据块的大小**

以 InnoDB 的一个`整数字段索引`为例，这个 N 差不多是 1200。这棵树高是 4 时，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到`树根的数据块总是在内存中的`，一个 10 亿行的表上一个整数字段的索引，查找一个值`最多只需要访问 3 次磁盘`。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

> MySql默认`一个节点`的长度为`16K`，一个整数（bigint）字段索引的长度为 8B，另外每个索引还跟着6B的指向其子树的指针；所以`16K/14B ≈ 1170`



# InnoDB的索引（B+树）

## 索引组织表

在 InnoDB中，表都是根据`主键顺序`以索引的形式存放的，这种存储方式的表称为`索引组织表`。

InnoDB 使用了 B+ 树索引模型，所以数据都是存储在` B+ 树`中的。

B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数



## 聚簇索引 和 二级索引

每一个索引在 InnoDB 里面对应一棵`B+ 树`，根据`叶子节点的内容`，索引类型分为`主键索引`和`非主键索引`。



* 主键索引的叶子节点存的是`整行数据`。在 InnoDB 里，主键索引也被称为`聚簇索引（clustered index）`

* 非主键索引的叶子节点存的是`主键的值`。在 InnoDB 里，非主键索引也被称为`二级索引（secondary index）`



**基于主键索引和普通索引的查询有什么区别？**

* 如果语句是 `select * from T where ID=500`，即主键查询方式，则只需要搜索 ID 这棵 B+ 树
* 如果语句是 `select * from T where k=5`，即普通索引查询方式，则需要先搜索` k 索引树`，得到 ID 的值为 500，再到` ID 索引树`搜索一次。这个过程称为`回表`



# 索引维护

B+ 树为了维护`索引有序性`，在插入新值时需要做必要的维护。



如图，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就`需要逻辑上挪动后面的数据`，空出位置。

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/20210719224056.png)

## 页分裂

而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时需要`申请一个新的数据页`，然后`挪动部分数据过去`。这个过程称为`页分裂`。在这种情况下，性能自然会受影响



除了性能外，`页分裂`操作还影响`数据页的利用率`。`原本放在一个页的数据，现在分到两个页中`，整体空间利用率降低大约 50%



## 页合并

当相邻两个页由于`删除了数据`，利用率很低之后，会将数据页做合并



## 自增主键 和 业务主键

**自增主键**

自增主键是指`自增列上定义的主键`，在建表语句中一般是这么定义的：

 `NOT NULL PRIMARY KEY AUTO_INCREMENT`

> 插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。



自增主键的插入数据模式正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是`追加操作`，都`不涉及到挪动其他记录`，也`不会触发叶子节点的分裂`



**业务主键**

有`业务逻辑`的字段做主键，则往往`不容易保证有序插入`，这样写数据成本相对较高



除了`考虑性能`外，还可以从`存储空间`的角度来分析



假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用`身份证号`做主键，还是用`自增字段`做主键呢？

> 由于每个非主键索引的叶子节点上都是主键的值。如果用`身份证号`做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用`整型`做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节



显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小



从性能和存储空间方面考量，自增主键往往是更合理的选择。



**什么场景适合用`业务字段`直接做主键**

1. 只有一个索引
2. 该索引必须是唯一索引

这就是典型的 KV 场景。由于没有其他索引，所以也就`不用考虑其他索引的叶子节点大小`的问题。



# InnoDB使用B+树的原因

## MySQL的存储结构

表存储结构，单位：表>段>区>页>行



在数据库中， 不论读一行，还是读多行，都是`将这些行所在的页进行加载`。也就是说存储空间的基本单位是`页`



一个页就是一棵树B+树的`节点`，`数据库I/O操作`的最小单位是页，与数据库相关的内容都会存储在页的结构里。



## B+树索引结构

在一棵B+树中，每个节点为都是一个页，每次新建节点的时候，就会`申请一个页空间`



同一层的节点为之间，通过页的结构构成了一个`双向链表`



**非叶子节点**

包括了多个索引行，每个索引行里存储`索引键`和`指向下一层页面的指针`

**叶子节点**

存储了关键字和行记录，在节点内部(也就是页结构的内部)记录之间是一个单向的表



## B+树页节点结构

**特点**

1. 将所有的记录分成几个组， 每组会存储多条记录

2. 页目录存储的是`槽(slot)`，槽相当于分组记录的索引，每个槽指针指向了不同组的最后一个记录

3. 我们通过槽定位到组，再查看组中的记录



**页的主要作用**

存储记录，在页中记录以`单链表`的形式进行存储



单链表优点是`插入、删除方便`，缺点是`检索效率不高`，最坏的情况要遍历链表所有的节点。因此页目录中提供了二分查找的方式，来提高记录的检索效率。



## B+树的检索过程

1. 从B+树的根开始，逐层找到叶子节点

2. 找到叶子节点为对应的数据页，将数据页加载到内存中，通过页目录的槽采用二分查找的方式先找到一个粗略的记录分组

3. 在分组中通过链表遍历的方式进行记录的查找



## 为什么要用B+树索引

数据库访问数据要通过页，一个页就是一个B+树节点，访问一个节点相当于一次I/O操作，所以越快能找到节点，查找性能越好。



B+树的特点就是够矮够胖，能有效地减少访问节点次数从而提高性能。



**对比一个二叉树、多叉树、B树和B+树**

1. 二叉树

二叉树是一种二分查找树，有很好的查找性能，相当于二分查找。

但是当N比较大的时候，树的深度比较高。数据查询的时间主要依赖于磁盘IO的次数，二叉树深度越大，查找的次数越多，性能越差。

最坏的情况是退化成了链表，为了让二叉树不至于退化成链表，人们发明了AVL树(平衡二叉搜索树)：任何结点的左子树和右子树高度最多相差1



2. 多叉树

多叉树就是节点可以是M个，能有效地减少高度，高度变小后，节点变少I/O自然少，性能比二叉树好了



3. B树

B树简单地说就是多叉树，每个叶子会存储数据，和指向下一个节点的指针。



例如要查找9，步骤如下

我们与根节点的关键字 (17，35)进行比较，9 小于 17 那么得到指针 P1；

按照指针 P1 找到磁盘块 2，关键字为(8，12)，因为 9 在 8 和 12 之间，所以我们得到指针 P2；

按照指针 P2 找到磁盘块 6，关键字为(9，10)，然后我们找到了关键字 9。



4. B+树

B+树是B树的改进，简单地说是：只有叶子节点才存数据，非叶子节点是存储的指针；所有叶子节点构成一个`有序链表`



例如要查找关键字16，步骤如下

与根节点的关键字 (1，18，35) 进行比较，16 在 1 和 18 之间，得到指针 P1(指向磁盘块 2)

找到磁盘块 2，关键字为(1，8，14)，因为 16 大于 14，所以得到指针 P3(指向磁盘块 7)

找到磁盘块 7，关键字为(14，16，17)，然后我们找到了关键字 16，所以可以找到关键字 16 所对应的数据。



## B+树与B树的不同

* B+树非叶子节点不存在数据只存索引，B树非叶子节点存储数据

* B+树使用链表连接所有叶子节点，区间查询效率更高，因为所有数据都在B+树的叶子节点，但是B树则需要通过`中序遍历`才能完成查询范围的查找。

* B+树每次都必须查询到叶子节点才能找到数据，而B树查询的数据可能不在叶子节点，也可能在，这样就会造成`查询的效率的不稳定`

* B+树查询效率更高，因为B+树矮更胖，高度小，`查询产生的I/O最少`



# 索引的概念

## 索引字段查询流程

T表的初始化语句

```sql
create table T (
    ID int primary key,
    k int NOT NULL DEFAULT 0, 
    s varchar(16) NOT NULL DEFAULT '',
    index k(k)) engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

在这个表 T 中，如果执行 `select * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？



这条 SQL 查询语句的执行流程：

1. 在` k 索引树`上找到 k=3 的记录，取得 ID = 300
2. 再到` ID 索引树`查到 ID=300 对应的 R3
3. 在` k 索引树`取下一个值 k=5，取得 ID=500
4. 再回到` ID 索引树`查到 ID=500 对应的 R4
5. 在` k 索引树取下一个值 k=6`，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，我们称为`回表`。这个查询过程`读了 k 索引树的 3 条记录（步骤 1、3 和 5）`，`回表了两次（步骤 2 和 4）`



## 覆盖索引

如果执行的语句是 `select ID from T where k between 3 and 5`，这时只需要查 ID 的值，`而 ID 的值已经在 k 索引树上了`，因此可以直接提供查询结果，不需要`回表`。

也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为`覆盖索引`。



由于`覆盖索引`可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的`性能优化手段`。



需要注意的是，在`引擎内部`使用覆盖索引在索引 k 上其实读了`三个记录`，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 `Server 层`来说，它就是`找引擎拿到了两条记录`，因此 `MySQL 认为扫描行数是 2`。



**来讨论一个问题：在一个市民信息表上，是否有必要将`身份证号`和`名字`建立联合索引？**

假设这个市民表的定义是这样的：

```sql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```



身份证号是市民的唯一标识。

也就是说，如果有根据`身份证号`查询市民信息的需求，只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？

> 如果现在有一个`高频请求`，要根据`市民的身份证号查询他的姓名`，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，`不再需要回表查整行记录，减少语句的执行时间`



## 最左前缀原则

如果现在要按照市民的身份证号去查他的家庭地址呢？

虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？

反过来说，`单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费`。应该怎么做呢？



B+ 树这种索引结构，可以利用`索引的“最左前缀”`，来定位记录。

> 我们用（name，age）这个`联合索引`来分析，索引项是按照`索引定义里面出现的字段顺序排序`的。



不只是索引的全部定义，只要`满足最左前缀`，就可以利用索引来加速检索。这个最左前缀可以是`联合索引的最左 N 个字段`，也可以是`字符串索引的最左 M 个字符`。



**在建立联合索引的时候，如何安排索引内的字段顺序**

评估标准是，索引的`复用能力`。

> 因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。
>
> 因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。



如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。

> 这时我们要考虑的原则就是空间了。
>
> 比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。



## 索引下推

> MySQL5.6之后有索引下推

前提：有对应的联合索引可以利用



如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。

> 以市民表的`联合索引（name, age）`为例

SQL 语句这么写：

```sql
 select * from tuser where name like '张%' and age=10 and ismale=1;
```

根据`前缀索引规则`，所以这个语句在搜索索引树时，`只能用 “张”`，找到第一个满足条件的记录 ID3。然后判断其他条件是否满足（当然，这还不错，总比全表扫描要好）



在 MySQL 5.6 之前，只能从 `ID3 开始一个个回表`。到主键索引上找出数据行，再对比字段值。

在无索引下推中，这个`过程 InnoDB 并不会去看 age 的值`，只是按顺序把“name 第一个字是’张’”的记录`一条条取出来回表`。因此，需要回表 4 次。



`无索引下推执行流程图`

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/05_%E7%B4%A2%E5%BC%95_01.jpg)



---



而 MySQL 5.6 引入的`索引下推优化（index condition pushdown)`， 可以在索引遍历过程中，`对索引中包含的字段先做判断`，直接过滤掉不满足条件的记录，减少回表次数



在有索引下推中，InnoDB 在 `(name,age) 索引`内部就`判断了 age 是否等于 10`，对于不等于 10 的记录，直接判断并跳过。在这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要`回表 2 次`。



`有索引下推执行流程图`

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/05_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95_02.jpg)


