# 不同引擎count(*) 的实现方式

## 实现方式

前提：在这讨论的是没有过滤条件的 count(*)

1. MyISAM 引擎

   把一个表的总行数存在了磁盘上，直接返回，很快

   > 如果加了 where 条件的话，MyISAM 表也是不能返回得很快的

2. InnoDB 引擎

   遍历全表，要把数据一行一行读出来，然后累积计数，相对没那么快。

   > 因为InnoDB的事务隔离级别默认是可重复读，在同一个时刻的多个查询，由于`多版本并发控制（MVCC）`，InnoDB 表“应该返回多少行”也是不确定的。
   >
   > 每一行记录都要`判断自己是否对这个会话可见`，所以 `count(*) `时只好把数据一行一行地读出依次判断是否可见，可见的行才能够用于计算“基于这个查询”的表的总行数



*** 问题： show table status 输出结果的 TABLE_ROWS(显示这个表当前有多少行) 能代替 count(*) 吗？**

答：不能，索引统计的值 TABLE_ROWS是通过`采样`来估算的；

实际上，TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准，官方文档说误差可能达到 40% 到 50%。



## 计数例子

假设表 t 中现在有 10000 条记录:

1. 会话 A 先启动事务并查询一次表的总行数

2. 会话 B 启动事务，插入一行后记录后，查询表的总行数

3. 会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数

   

假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/14_%E4%BC%9A%E8%AF%9Dabc%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png)



结论：在最后一个时刻，三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同



## InnoDB中count(*) 所做的优化

### 遍历最小的索引树

InnoDB 是索引组织表，主键索引树的叶子节点是`数据`，而普通索引树的叶子节点是`主键值`；

所以，普通索引树比主键索引树小很多。



对于 count(*) ，MySQL 优化器会`找到最小的那棵树来遍历`；

在保证逻辑正确的前提下，`尽量减少扫描的数据量`，是数据库系统设计的通用法则之一



# 不同count的区别

## 效率排序

count(*) ≈count(1)>count(主键 id)>count(字段)

> 建议尽量使用 count(*)



count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值



1. `count(*)、count(主键id)、count(1) `：表示返回满足条件的结果集的`总行数`

2. `count(字段）`：表示`返回满足条件的数据行`里面，`参数“字段”不为 NULL 的总个数`



## 执行流程

**count(*)**

不会把全部字段取出来，而是专门做了优化，不会取值，count(*) 判断不为null的则按行累加。



**count(主键 id)**

InnoDB 引擎遍历整张表，把每一行的 id 值都取出来，返回给 server 层，server 层拿到 id 后，判断不为null的，就按行累加



**count(1)**

InnoDB 引擎遍历整张表，但不取值，server 层对于返回的每一行，放一个数字“1”进去，判断不为null的，按行累加



count(1) 执行得要比 count(主键 id) 快

> 因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。



**count(字段)**

1. 如果这个“字段”是定义为 `not null` 的话，一行行地从记录里面读出这个字段，判断不为 null的，按行累加
2. 如果这个“字段”定义`允许为 null`，那么执行的时候，判断到有可能是 null，还要把值取出来`再判断一下`，不是 null 才累加



# 其他计数方法

## 用redis保存计数

1. 把表的总行数存在redis中
2. 表每插入一行 Redis 计数就加 1
3. 表每被删除一行 Redis 计数就减 1
4. 定时把这个总行数持久化存储起来



**可能存在的问题**

1. 缓存的丢失更新

> 比如数据库插入了一行，redis计数也增加了，但redis异常重启了，redis数据没有持久化，redis恢复正常后就丢失了这个计数
>
> 可以在redis重启以后，到对应表执行一次count(*)查总数，然后再写入redis

2. 即使 Redis 正常工作，这个值还是逻辑上不精确的



假设有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的 100 条记录。那么，这个页面的逻辑就需要先到 Redis 里面取出总计数，再到数据表里面取数据记录



**操作例子1**

先插入记录到数据库，redis再增加计数

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/14_%E4%BC%9A%E8%AF%9Dab%E6%97%B6%E5%BA%8F%E5%9B%BE2.png)

1. 会话 A先往数据库插入一行记录，然后 Redis 计数加 1

2. 会话 B 在 T3 时刻查询时，会查到新插入的 R 这个记录，但是 Redis 的计数还没加 1，即出现数据不一致



**操作例子2**

先redis增加计数，再插入记录到数据库

![](https://gitee.com/sinkhaha/picture/raw/master/img/mysql/14_ab%E6%97%B6%E5%BA%8F%E5%9B%BE3.png)



1. 会话A先增加redis计数，然后再插入数据到数据库

2. 会话 B 在 T3 时刻查询时，查到Redis的计数加了 1 了，但还查不到新插入的 R 这一行，即数据不一致



在并发系统里，无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使 Redis 正常工作，这个计数值还是逻辑上不精确的。



## 另外一张表保存计数

用单独的一张计数表 C存放计数，可能存在的问题

1. 存表里解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的
2. 可以解决计数不精确的问题



![](https://gitee.com/sinkhaha/picture/blob/master/img/mysql/14_%E4%BC%9A%E8%AF%9Dab%E6%97%B6%E5%BA%8F%E5%9B%BE4.png)



1. 会话A先增加计数，然后再插入记录

2. 会话 B 在 T3 执行查询，因为这时更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见

因此，会话 B 看到的结果里， 查计数值和“最近 100 条记录”看到的结果，逻辑上就是一致的

