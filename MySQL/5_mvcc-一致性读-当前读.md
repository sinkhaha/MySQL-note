# 一致性读 和 当前读

> 本文前提是MySQL是InnoDB引擎

## 一致性读/快照读

在**可重复读隔离**级别时，事务T启动时会创建一个`一致性视图 read-view`，之后事务 T 执行期间，即使有其他事务修改了数据，事务T在执行select等查询语句查到的值仍然跟在启动事务时看到的值一样，此时是一致性读，也叫`快照读`。



**一致性视图**

一致性视图没有物理结构，作用是`事务执行期间用来定义“我能看到什么数据”`。

InnoDB 在实现 MVCC 时用到一致性视图，它用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。



> **快照读**是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句



## 当前读

1. update语句是当前读

事务T要执行update时，如果刚好有其他事务拥有这一行的行锁，则事务T会被锁住，事务T进入等待状态，因为此时事务T的update是`当前读`，需要拿到该行数据最新的值。

2. select语句加锁是当前读

select 语句如果加锁(加上 lock in share mode 或 for update)，也是当前读



> **当前读**是基于 `行锁 + 间隙锁`实现的



## 事务的启动时机

* begin/start transaction ：并不是一个事务的起点，在执行到它之后的第一个操作表的语句，事务才真正启动。

  > 此时一致性视图是在执行第一个select语句才创建的

* start transaction with consistent snapshot ：马上启动一个事务

  > 此时一致性视图是在执行后就创建了





# 例子

**建表语句**

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(id, k) values(1,1),(2,2);
```



**事务 A\B\C 的执行流程**

 图1

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/08_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB_01.png)

1. 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后
2. 事务 C没显式地使用 begin/commit，因为 `update 语句本身就是一个事务`，语句完成时会`自动提交`
3. 事务 B 在事务C更新了行之后查询 

这时，事务 B 查到的 k 的值是 3（当前读），而事务 A 查到的 k 的值是 1（一致性读）



如果把事务A的最后一句`select * from T where id = 1`修改一下，加上` lock in share mode 或 for update`此时事务A也会被`阻塞`，等待id为1行锁的释放，因为此时是`当前读`，需要等待事务B提交后，事务A的查询才能继续执行，此时得到的值是事务B更新后的值，即3。

```sql
mysql> select k from t where id=1 lock in share mode; // 加了读锁（S 锁，共享锁）
mysql> select k from t where id=1 for update; // 加了写锁（X 锁，排他锁）
```



# MVCC和快照

在可重复读隔离级别下，`事务在启动时就“拍了个快照”`。注意，这个快照是基于`整库`的。



## transaction id

InnoDB 里面每个事务有一个`唯一的事务 ID`，叫作 `transaction id`。

它是在`事务开始`时向 InnoDB 的事务系统申请的，是按申请顺序严格递增的

> `先开始的事务`获取的事务ID总是小于后开启的事务ID
>
> * 非只读事务的ID是一个从1自增的数值
>
> * 只读事务是不会分配事务ID的： 
>
> 1. 减小活跃数组的长度
> 2. 减少事务ID申请次数，即并发申请事务ID造成的锁冲突 
> 3. 防止了事务ID自增过快
>
> https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html



## 数据多版本

数据表中的`每一行记录`，其实都可能有`多个版本 (row)`，每个版本有自己的 `row trx_id`

> 每次`事务更新数据`时，都会`生成一个新的数据版本`，并且把 transaction id 赋值给这个数据版本的事务 ID，记为` row trx_id`。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它



InnoDB 利用了`“所有数据都有多个版本”`的这个特性，实现了`“秒级创建快照”`的能力。



图 2 ：一个记录被多个事务连续更新后的状态

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/08_%E4%BA%8B%E5%8A%A1_01.png)

图中`虚线框`里是`同一行数据的 4 个版本`

> 当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 `row trx_id 也是 25`



更新语句会生成 undo log（回滚日志），实际上`图中的三个虚线箭头，就是 undo log`；而 V1、V2、V3 并`不是物理上真实存在`的，而是每次需要时根据`当前版本 和 undo log `计算出来的

> 比如，需要 V2 时，就是通过 V4 依次执行 U3、U2 算出来



按照`可重复读`的定义，一个事务启动时，能够看到`所有已经提交的事务结果`。但是之后，这个事务执行期间，其他事务的更新对它不可见。



因此，一个事务只需要在启动时声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。



## 视图数组

在实现上， InnoDB 为每个事务构造了一个`数组`，用来保存这个事务启动瞬间，当前正在`“活跃”的所有事务 ID`。活跃”指的是启动了但还没提交



* 低水位：数组里 事务 ID 的最小值(一定在视图数组里)
* 高水位：当前系统里面`已经创建过的事务 ID 的最大值加 1` (是系统中的，不一定在视图数组里)



**当前事务的一致性视图(read-view)**：即这个视图数组 和 高水位 的组合



**数据版本的可见性规则**：就是`基于数据的 row trx_id `和这个`一致性视图`的对比结果得到的



这个`视图数组`把所有的 `row trx_id `分成了几种不同的情况

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/08_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB_02.png)

`图 3 数据版本可见性规则`



对于`当前事务的启动瞬间`来说，一个数据版本的` row trx_id`，有以下几种可能：

1. 如果落在`绿色`部分，表示这个版本是 已提交的事务 或者 当前事务自己生成的，这个数据是`可见的`

2. 如果落在`红色`部分，表示这个版本是由 将来启动的事务生成的，是肯定`不可见`的

3. 如果落在`黄色`部分，那就包括两种情况

   > a. 若 row trx_id 在数组中，表示这个版本是由`还没提交的事务生成的`，不可见
   >
   > b. 若 row trx_id 不在数组中，表示这个版本是`已经提交了的事务生成的`，可见

> 比如，对于图 2 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。



继续看一下图 1 中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k=1。

我们先做如下假设：

1. 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99
2. 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务
3. 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90

此时：

事务 A 的视图数组就是`[99,100]`

事务 B 的视图数组是`[99,100,101]`

事务 C 的视图数组是`[99,100,101,102]`



图 4 `事务 A 查询数据逻辑图`

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/08_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB_04.png)

1. 第一个`有效更新`是事务 C，把数据从 (1,1) 改成了 (1,2)

   > 这时这个数据的最新版本的` row trx_id `是 102，而 90 这个版本已经成为了历史版本

2. 第二个`有效更新`是事务 ，把数据从 (1,2) 改成了 (1,3)

   > 这时这个数据的最新版本`（即 row trx_id）`是 101，而 102 又成为了历史版本



在事务 A 查询时，其实`事务 B 还没有提交`，但是它生成的 (1,3) 这个版本已经变成`当前版本`了。但这个版本对事务 A 必须是`不可见的`，否则就变成脏读了。



现在`事务 A `要来读数据了，它的视图数组是`[99,100]`。读数据都是从当前版本读起的。

所以事务 A 查询语句的读数据流程是这样的：

1. 找到 (1,3) 时，判断出 `row trx_id=101`，比高水位大，处于红色区域，`不可见`
2. 接着，找到上一个历史版本，一看 `row trx_id=102`，比高水位大，处于红色区域，`不可见`
3. 再往前找，终于找到了（1,1)，它的 `row trx_id=90`，比低水位小，处于绿色区域，`可见`



## 可见性规则总结

一个数据版本，对于一个事务视图来说，`除了自己的更新总是可见以外`，有三种情况：

1. 版本未提交，不可见
2. 版本已提交，但是是在视图创建后提交的，不可见
3. 版本已提交，而且是在视图创建前提交的，可见



我们用`这个规则`来判断图 4 中的查询结果，事务 A 的查询语句的`视图数组`是在`事务 A 启动的时候生成的`，这时：

1. (1,3) 还没提交，属于情况 1，不可见；
2. (1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；
3. (1,1) 是在视图数组创建之前提交的，可见。



## update时是当前读

update都是`先读后写的`，而这个读，只能`读当前的值`，称为`“当前读”（current read）`



例子：图 6 事务 A、B、C'的执行流程

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/08_%E4%BA%8B%E5%8A%A1_07.png)



事务 C’的不同是更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。



因为事务 C'没提交，也就是(1,2) 这个版本上的`写锁还没释放`。而事务 B 是`当前读`，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C'释放这个锁，才能继续它的当前读。

这时，事务 C'没提交，也就是说` (1,2) 这个版本上的写锁还没释放`。而事务 B 是`当前读`，`必须要读最新版本`，而且`必须加锁`，因此就被`锁住`了，必须等到事务 C'释放这个锁，才能继续它的当前读。



图 7 事务 B 更新逻辑图（配合事务 C'）

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/08_%E4%BA%8B%E5%8A%A1_08.png)



## 事务的可重复读怎么实现的

可重复读的核心就是`一致性读（consistent read）`；

而事务更新数据时，只能用`当前读`。如果当前的记录的行锁被其他事务占用的话，就需要进入`锁等待`。



而`读提交`的逻辑和`可重复读`的逻辑类似，它们最主要的区别是：

* 在`可重复读`隔离级别下，只需要在`事务开始`时创建一致性视图，之后事务里的其他查询都共用这个一致性视图
* 在`读提交`隔离级别下，`每一个语句执行前`都会`重新算出一个新的视图`



在`读提交`隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？

`“start transaction with consistent snapshot; ”`开始执行就创建了一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。



下面是`读提交`时的状态图，可以看到`这两个查询语句的创建视图数组的时机`发生了变化，就是图中的 read view 框。

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/mysql/08_%E4%BA%8B%E5%8A%A1_09.jpg)

图 8 读提交隔离级别下的事务状态图



`事务 A 的查询语句`的`视图数组`是在执行这个语句时创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。在这个时刻：

* (1,3) 还没提交，属于情况 1，不可见
* (1,2) 提交了，属于情况 3，可见

所以这时事务 A 查询语句返回的是 k=2。显然地，事务 B 查询结果 k=3



# 小结

InnoDB 的`行数据`有`多个版本`，每个数据版本有自己的 row trx_id，`每个事务或者语句`有自己的一致性视图。



1. 普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性

* 对于可重复读，查询只承认在事务启动前就已经提交完成的数据

* 对于读提交，查询只承认在语句启动前就已经提交完成的数据

  

2. 而当前读，总是读取已经提交完成的最新版本

