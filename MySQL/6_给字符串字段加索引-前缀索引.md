# 建表语句

假如用户表里有个邮箱email字段，系统支持`邮箱登陆`，此时会以email作为查询条件

```sql
create table SUser(
  ID bigint unsigned primary key,
  email varchar(64)
)engine=innodb;
```

此时要怎么给email字段加索引呢



# 字符串的前缀索引

### 什么是前缀索引

MySQL 是支持`前缀索引`的，也就是可以定义字符串的一部分作为索引

> 默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串



### 前缀索引的优缺点

1. 优点：索引树所占空间更小

2. 缺点：如果查询到email前缀匹配的数据，此时会`回表`去主键树查email字段的完整数据看是否匹配，不匹配则记录取二级索引树的下一条数据重复以上操作，即`增加额外的记录扫描次数`



**为email整个字段创建索引**

```sql
alter table SUser add index index1(email);
```

**为email字段的前6个字符创建索引**

> 注意此时索引树中只会包含email的前6个字符

```sql
alter table SUser add index index2(email(6));
```



看下在这两个索引定义下该查询语句分别是怎么执行的

```sql
select id,name,email from SUser where email='zhangssxyz@xxx.com';
```



**如果使用的是index1( email 整个字符串的索引结构)，执行顺序是这样的：**

1. 从 index1 索引树找到满足索引值是`’zhangssxyz@xxx.com’`的这条记录，取得 ID2 的值
2. 到`主键索引上`查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集
3. 取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 `email='zhangssxyz@xxx.com’`的条件了，循环结束

这个过程中，只需要回`主键索引`取一次数据，所以系统认为`只扫描了一行`



**如果使用的是index2( email(6) 索引的结构)，执行顺序是这样的：**

1. 从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1
2. 到主键上查到主键值是 ID1 的行，判断出 email 的值不是`’zhangssxyz@xxx.com’`，这行记录丢弃；
3. 取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集
4. 重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束

在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行



**结论：**

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本



# 怎么定义前缀的长度

实际上，在建立索引时关注的是`区分度`，区分度越高越好。因为区分度越高，意味着重复的键值越少。



因此，可以通过`统计索引上有多少个不同的值`来判断要使用多长的前缀。



1. 首先，算出这个列上有多少个不同的值：

```sql
select count(distinct email) as L from SUser;
```

2. 然后，依次选取不同长度的前缀来看这个值，比如要看一下` 4~7 个字节`的前缀索引

```sql
select 
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
```

当然，使用前缀索引很可能会损失区分度，所以需要预先设定一个可以接受的损失比例，比如 5%。

然后，在返回的` L4~L7 中`，找出不小于` L * 95% 的值`，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6



# 前缀索引对覆盖索引的影响

1. 前缀索引可能会`增加扫描行数`，这会影响到性能
2. 前缀索引`用不上`覆盖索引对查询性能的优化，如果查询结果需要email的值，需要回一次表去主键树查email的完整数据



# 其他创建索引的方式

假如现在要以`身份证号`来创建索引，需要怎么创建



**分析**

1. 身份证号比较长，整个字段创建索引`浪费空间`
2. 身份证号其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。所以需要选比较长的前缀创建前缀索引，这样也会浪费空间



**2种实现方式**

1. 使用`倒序存储`，再创建前缀索引

> 倒序用于绕过字符串本身前缀的区分度不够的问题
>
> 存储身份证号时把它倒过来存，查询时查询条件为倒过来的身份证号

2. 使用 hash 字段

> 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消
>
> 
>
> 在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。
>
> 在插入数据时，也计算后插入该hash字段的值（如使用crc32() 这个函数），查询时根据hash字段和身份证号查，因为hash可能有冲突，所以查询条件需要加上身份证号



**区别**

相同点：

以上两种方法都`不支持范围查询`，只能等值查询



不同点：

1. 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段

   > 当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了

2. 在 CPU 消耗方面，倒序方式每次写和读时，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些

3. 从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些

   > 因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。


